<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 6.3.0"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="format-detection" content="telephone=no"><title>第一章 构造抽象过程 - duinomaker&#39;s blog</title><meta name="description" content="Notes on SICP chapter 1 - Building Abstractions with Procedures"><meta property="og:type" content="website"><meta property="og:title" content="第一章 构造抽象过程"><meta property="og:url" content="https://duinomaker.top/SICP/notes/1/"><meta property="og:site_name" content="duinomaker&#39;s blog"><meta property="og:description" content="Notes on SICP chapter 1 - Building Abstractions with Procedures"><meta property="og:locale"><meta property="og:image" content="https://duinomaker.top/images/og_image.png"><meta property="article:published_time" content="2020-04-09T15:10:45.000Z"><meta property="article:modified_time" content="2021-05-25T02:28:17.000Z"><meta property="article:author" content="duinomaker"><meta property="article:tag" content="mathematics"><meta property="article:tag" content="programming"><meta property="article:tag" content="algorithm"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://duinomaker.top/images/og_image.png"><meta name="twitter:creator" content="@duinomaker"><meta name="twitter:site" content="@duinomaker"><meta property="fb:admins" content="100043022235251"><link rel="canonical" href="https://duinomaker.top/SICP/notes/1/"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin="anonymous"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="apple-touch-icon" type="image/png" sizes="57x57" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" type="image/png" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" type="image/png" sizes="72x72" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" type="image/png" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="icon" type="image/svg+xml" href="/images/favicon.svg"><link rel="alternate icon" type="image/png" href="/images/favicon.png"><link rel="shortcut icon" type="image/x-icon" sizes="32x32" href="/images/favicon-32x32.ico"><link rel="shortcut icon" type="image/x-icon" sizes="16x16" href="/images/favicon-16x16.ico"><link rel="preload" href="/assets/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous"><link rel="preload" href="/assets/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@latest/css/bulma.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,italic,500,500italic|Source+Code+Pro|Alegreya:400,italic,500,500italic"><link rel="stylesheet" href="/assets/font-awesome/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@latest/styles/atom-one-light.min.css"><link rel="stylesheet" href="/assets/style.css"></head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand is-flex-center"> <a class="navbar-item navbar-logo" href="/"><img src="/images/misc/logo.svg" alt="第一章 构造抽象过程" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"> <a class="navbar-item" href="/">Home</a> <a class="navbar-item" href="/archives/">Archives</a> <a class="navbar-item" href="/categories/">Categories</a> <a class="navbar-item" href="/notes/">Notes</a> <a class="navbar-item" href="/about/">About</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;" rel="external nofollow noreferrer"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column is-12 has-order-2 column-main"><div class="card"><div class="card-content article"><div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto"><div class="level-left"> <time class="level-item has-text-grey" datetime="2020-04-09T15:10:45.000Z">April 09, 2020</time><span class="level-item has-text-grey"><i class="fas fa-user"></i> &nbsp;<a class="has-link-grey" rel="author" href="https://duinomaker.top/">duinomaker</a></span></div></div><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"> 第一章 构造抽象过程</h1><div class="content has-math"><style>.article .title,.article h1,.article h2,.article h3,.article h4,.article h5,.article h6{font-family:"Microsoft YaHei",sans-serif}</style><hr><h2 id="1-1-程序设计的基本元素"><a href="#1-1-程序设计的基本元素" class="headerlink" title="1.1 程序设计的基本元素"></a>1.1 程序设计的基本元素</h2><div class="foreword"><p>为了让我们能通过程序语言组织自己有关计算过程的思想，每一种强有力的语言都提供了三种机制，使我们能够将简单的认识组合起来形成更复杂的认识：</p><ul><li><strong>基本表达式</strong>，指语言中最基本的实体</li><li><strong>组合的方法</strong>，通过它们可以用简单元素构成复合元素</li><li><strong>抽象的方法</strong>，通过它们可以给复合元素命名，并将其视为单元操作</li></ul></div><hr><p><strong>组合式求值</strong>有以下步骤：</p><ol><li>对组合式的各个子表达式求值</li><li>将运算符的值应用于其它子表达式的值</li></ol><p>对子表达式求值时也必须遵循这样的步骤，这意味着求值步骤本身就是递归的。</p><p><code>define</code> 是我们给值<strong>命名</strong>的方式，也是最简单的抽象方式，形如 <code>(define x 3)</code>&hairsp;。这样做会导致名字 <code>x</code> 与值 <code>3</code> 相关联。将名字与值相关联，又能根据名字提取出值，解释器需要存储空间来维护名字-值关联，这存储空间被称为<strong>环境</strong>。</p><p><strong>过程定义</strong>形如 <code>(define (&lt;name&gt; &lt;formal parameters&gt;) &lt;body&gt;)</code>，将用对应的实际参数替换形式参数，再求值的这一过程，在环境中绑定给一个名字，便于以后的调用。</p><p><strong>应用序求值</strong>与<strong>正则序求值</strong>是表达式求值的两种方式。应用序求值时，解释器首先对运算符和各个对象求值，之后将得到的过程应用于得到的实际参数。而正则序求值时，先不求出运算对象的值，直到需要它们时再去求。</p><ul><li>应用序，概括为 “先求值而后应用”</li><li>正则序，概括为 “完全展开后规约”</li></ul><blockquote><p>Lisp 采用应用序求值，部分原因在于这样做能避免对于表达式的重复求值，从而可以提高一些效率。更重要的是，在超出了可以采用代换方式模拟过程的范围后，正则序的处理将变得复杂得多。</p></blockquote><p><strong>条件表达式和谓词</strong>，形如</p><pre><code>(cond (&lt;p1&gt; &lt;e1&gt;)
      (&lt;p2&gt; &lt;e2&gt;)
      ...
      (&lt;pn&gt; &lt;en&gt;))

(if &lt;predicate&gt; &lt;consequent&gt; &lt;alternative&gt;)
</code></pre><p><code>cond</code> 之后跟随着形如 <code>(&lt;p&gt; &lt;e&gt;)</code> 的表达式，称为从句。从句中的 <code>&lt;p&gt;</code> 是谓词，与结果表达式 <code>&lt;e&gt;</code> 相对应。整个 <code>cond</code> 表达式的值是从左到右第一个谓词为真的从句的结果表达式，其中 <code>else</code> 是一个永远为真的谓词。</p><p>要对一个 <code>if</code> 表达式求值，首先对 <code>&lt;predicate&gt;</code> 求值。如果其为真，求出 <code>&lt;consequent&gt;</code> 的值，否则求出 <code>&lt;alternative&gt;</code> 的值作为整个 <code>if</code> 表达式的值。</p><p>由于 <code>cond</code> 和 <code>if</code> 不一定对其所有子表达式求值，它们不是一般的过程，而是<strong>特殊形式</strong>。</p><p>形式参数叫什么名字，其实无所谓，这样的名字称为<strong>约束变量</strong>。如果一个变量不是被约束的，我们就称它为自由的。名字在其中被约束的表达式的集合称为名字的<strong>作用域</strong>。约束变量在将其作为形式参数的过程中的作用域是这个过程的过程体。</p><p><strong>词法作用域</strong>是作用域的一种工作模型。内层过程中的自由变量，实际上是外围过程定义中的约束变量。</p><p>嵌套定义的过程，称为<strong>块结构</strong>。块结构的好处是，可以省去将某些变量在内层过程中传递的过程。</p><h2 id="1-2-过程与它们所产生的计算"><a href="#1-2-过程与它们所产生的计算" class="headerlink" title="1.2 过程与它们所产生的计算"></a>1.2 过程与它们所产生的计算</h2><div class="foreword"><p>能够遇见所作所为的后果，是一种很重要的能力。</p><p>过程规定了计算状态如何从之前的计算状态演变而来。计算的具体行为很难捉摸，但我们可以找到演变的一般模式。从全局的角度判断计算状态的演变方式，这就是这一节所需要学习的内容。</p></div><hr><p><strong>递归过程</strong>与<strong>递归计算</strong>是不同的概念：递归过程是指一个过程的定义中，包含了引用自身的表达式。而递归计算，指的是递归实际的演变方式。</p><p><strong>线性递归</strong>与<strong>线性迭代</strong>是计算的两种演变方式：</p><ul><li>线性递归：计算过程中不断展开表达式，随之构建起一条<strong>延迟操作</strong>的链，并在这些运算实际进行时收缩。当需要保存的信息量（正如延迟操作的步数）与问题规模的增长成正比时，称为线性递归。</li><li>线性迭代：没有增长和收缩过程，需要保存的信息是一定数量的状态变量，并且用一套规则来指定状态变量的更新方式。当计算步数与问题规模的增长成正比时，称为线性迭代。</li></ul><p>迭代过程中，状态变量完全描述了当前的状态，只要提供这些状态变量，计算就能随时进行下去；而递归过程就不同了，递归过程中记录了变量以外的额外信息，用于告诉解释器 “我们在延迟操作链上的什么位置”。</p><p><strong>树形递归</strong>是指递归过程中多次引用自身，使 “延迟操作链” 分叉为树形结构。树形递归往往需要极多运算资源，但它不是无用的。处理有层级结构的数据时，树形递归是个自然而强大的工具；处理数字时，树形递归方式更容易理解。</p><p>对于树形递归的计算过程中的每一个节点，只需保存树中在其之上的节点的信息。一般来说，树形递归的计算所需的步骤数正比于树中的节点数，所需空间正比于树的最大深度。</p><p>树形递归可以使用记忆化的方法进行优化，如<a href="/SICP/exercises/3-3/#Exercise-3-27">练习 3.27</a>，在计算斐波那契数列时虽然使用了树形递归的形式，但由于可以利用之前计算得出的值，生成的整个递归树只有一条链；整个程序可以在线性时间内计算出结果。</p><p><strong>增长阶</strong>为计算所需要的资源量，提供了粗略的估计。设 ${\rm R}(n)$ 为问题规模为 $n$ 时所需的计算资源量。当</p><p>$$\exists k_1,k_2,N\;\forall n&gt;N\,(k_1f(n)\leq{\rm R}(n)\leq k_2f(n))$$</p><p>成立时，我们称 ${\rm R}(n)$ 有 $\Theta(f(n))$ 的增长阶，记作 ${\rm R}(n)\sim\Theta(f(n))$&hairsp;。</p><p><strong><span style="font-weight:500">Lamé</span>定理</strong>：如果用欧几里德算法计算一对数的 GCD 需要执行 $k$ 步，那么更小的那个数一定不小于第 $k$ 个斐波那契数。</p><p>运用这个定理，可以很方便地分析欧几里德算法的增长阶。设更小的数为 $n$，则一定有 $n\geq{\rm Fib}(k)\approx\frac{\phi^k}{\sqrt5}$&hairsp;。从此可以看出，$k$ 正比于 $\log_\phi(n)$ 增长，所以欧几里德算法的增长阶为 $\Theta(\log n)$&hairsp;。</p><p><strong>费马小定理</strong>：若 $n$ 是素数，则对于任意 $a$ 不是 $n$ 的倍数，都有 $a^n\equiv a\;({\rm mod}\;n)$，它的另一个形式是 $a^{n-1}\equiv1\;({\rm mod}\;n)$，在<a href="/posts/miller-rabin/" target="_self">$\text{Miller–Rabin}$素性测试</a>中得以应用。</p><h2 id="1-3-用高阶函数做抽象"><a href="#1-3-用高阶函数做抽象" class="headerlink" title="1.3 用高阶函数做抽象"></a>1.3 用高阶函数做抽象</h2><div class="foreword"><p>为了增加描述能力，一门强大的语言需要：将共有的模式命名并建立抽象，而后直接在抽象的层次上工作。</p><p>这就需要引入高阶过程，它们以过程为参数，或者以过程为返回值。</p></div><hr><p>将过程作为参数，或者将过程作为其值，以便用过程来处理过程，这样的过程称作<strong>高阶过程</strong>。</p><p><strong>匿名过程</strong>形如 <code>(lambda (&lt;formal-parameters&gt;) &lt;body&gt;)</code>&hairsp;。<code>lambda</code> 像 <code>define</code> 一样创造过程，但是不为它们绑定名称。</p><p><strong>局部变量</strong>使用以下语法进行绑定，它们的作用域是 <code>&lt;body&gt;</code> 部分：</p><pre><code>(let ((&lt;var1&gt; &lt;exp1&gt;)
      (&lt;var2&gt; &lt;exp2&gt;)
      ...
      (&lt;varn&gt; &lt;expn&gt;))
   &lt;body&gt;)
</code></pre><p><code>let</code> 也是一种特殊形式，和调用过程时，将表达式的值绑定给形式参数的原理一样，它并没有引入新的机制。</p><p>“$\mapsto$” 这个符号叫做<strong>映射</strong>&hairsp;$($<em>$\textit{maps to}$</em>$)$，是 <code>lambda</code> 在数学中的表达。例如 $y\mapsto x/y$ 可以被表达为 <code>(lambda (y) (/ x y))</code>&hairsp;。</p><p>一般来说，程序语言会对计算元素的可操作方式作出限制。而带有最少限制的元素被称为拥有<strong>第一级</strong>状态，这些元素有这些特点：</p><ul><li>可以被绑定给一个变量</li><li>可以作为参数传递给一个过程</li><li>可以被一个过程作为返回值</li><li>可以存储在数据结构中</li></ul><blockquote><p>Lisp 语言为过程赋予了完全的第一级状态，由此获得的描述能力是惊人的。</p><p>这样做是有代价的，也为解释器的实现提出了挑战：实现第一级状态的过程需要为过程中的自由变量预留存储空间，即使某个过程并没有被调用。</p></blockquote></div></div></div><div class="card"><div class="card-content"><h3 class="title is-5 has-text-weight-normal">Comments</h3><div id="valine-thread" class="content"></div><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>new Valine({el:"#valine-thread",notify:!1,verify:!1,app_id:"jUDJCYuOij3UzEzFmRpQer5U-gzGzoHsz",app_key:"h2AVOMeF8QsLYFdVVbbf9d7k",placeholder:"Suggestions are welcome.",lang:"en"})</script></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start has-text-centered-mobile has-mb-6-mobile"><p>This work is licensed under a <a rel="license noopener external nofollow noreferrer" title="Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">Creative Commons License</a></p></div><div class="level-end has-text-centered-mobile has-mb-5-mobile"><p class="is-size-7">&copy;&nbsp;2020<span style="padding-left:.06em">–</span>2023&nbsp;duinomaker<span>&nbsp;&nbsp;|&nbsp;&nbsp;</span><i class="fas fa-file-word"></i>&nbsp;57.5k&nbsp;words in total<span>&nbsp;&nbsp;|&nbsp;&nbsp;</span><a class="has-link-black-ter" rel="license noopener external nofollow noreferrer" title="Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank"><i class="fab fa-creative-commons"></i>&nbsp;&nbsp;<i class="fab fa-creative-commons-by"></i>&nbsp;&nbsp;<i class="fab fa-creative-commons-nc"></i>&nbsp;&nbsp;<i class="fab fa-creative-commons-sa"></i></a></p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script>var IcarusThemeSettings={site:{url:"https://duinomaker.top",external_link:{enable:!0,exclude:[]}},article:{highlight:{clipboard:!1,fold:"unfolded"}}}</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js" defer="defer"></script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/auto-render.min.js" defer="defer"></script><script>document.addEventListener("DOMContentLoaded",function(){for(contents=document.getElementsByClassName("has-math"),i=0;i<contents.length;++i)renderMathInElement(contents[i],{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script src="/assets/main.js" defer="defer"></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"> <input type="text" class="searchbox-input ins-search-input" placeholder="Type something..."><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)"},CONTENT_URL:"/assets/content.json"}</script><script src="/assets/insight.js" defer="defer"></script><link rel="stylesheet" href="/assets/search.css"><link rel="stylesheet" href="/assets/insight.css"></body></html>