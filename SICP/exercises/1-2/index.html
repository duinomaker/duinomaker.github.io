<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 6.3.0"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="format-detection" content="telephone=no"><title>1.2 过程与它们所产生的计算 - duinomaker&#39;s blog</title><meta name="description" content="Solutions to exercises in SICP section 1.2 - Procedures and the Processes They Generate"><meta property="og:type" content="website"><meta property="og:title" content="1.2 过程与它们所产生的计算"><meta property="og:url" content="https://duinomaker.top/SICP/exercises/1-2/"><meta property="og:site_name" content="duinomaker&#39;s blog"><meta property="og:description" content="Solutions to exercises in SICP section 1.2 - Procedures and the Processes They Generate"><meta property="og:locale"><meta property="og:image" content="https://duinomaker.top/images/og_image.png"><meta property="article:published_time" content="2020-04-09T15:10:45.000Z"><meta property="article:modified_time" content="2021-05-25T02:28:01.000Z"><meta property="article:author" content="duinomaker"><meta property="article:tag" content="mathematics"><meta property="article:tag" content="programming"><meta property="article:tag" content="algorithm"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://duinomaker.top/images/og_image.png"><meta name="twitter:creator" content="@duinomaker"><meta name="twitter:site" content="@duinomaker"><meta property="fb:admins" content="100043022235251"><link rel="canonical" href="https://duinomaker.top/SICP/exercises/1-2/"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin="anonymous"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="apple-touch-icon" type="image/png" sizes="57x57" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" type="image/png" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" type="image/png" sizes="72x72" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" type="image/png" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="icon" type="image/svg+xml" href="/images/favicon.svg"><link rel="alternate icon" type="image/png" href="/images/favicon.png"><link rel="shortcut icon" type="image/x-icon" sizes="32x32" href="/images/favicon-32x32.ico"><link rel="shortcut icon" type="image/x-icon" sizes="16x16" href="/images/favicon-16x16.ico"><link rel="preload" href="/assets/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous"><link rel="preload" href="/assets/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@latest/css/bulma.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,italic,500,500italic|Source+Code+Pro|Alegreya:400,italic,500,500italic"><link rel="stylesheet" href="/assets/font-awesome/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@latest/styles/atom-one-light.min.css"><link rel="stylesheet" href="/assets/style.css"></head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand is-flex-center"> <a class="navbar-item navbar-logo" href="/"><img src="/images/misc/logo.svg" alt="1.2 过程与它们所产生的计算" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"> <a class="navbar-item" href="/">Home</a> <a class="navbar-item" href="/archives/">Archives</a> <a class="navbar-item" href="/categories/">Categories</a> <a class="navbar-item" href="/notes/">Notes</a> <a class="navbar-item" href="/about/">About</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;" rel="external nofollow noreferrer"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column is-12 has-order-2 column-main"><div class="card"><div class="card-content article"><div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto"><div class="level-left"> <time class="level-item has-text-grey" datetime="2020-04-09T15:10:45.000Z">April 09, 2020</time><span class="level-item has-text-grey"><i class="fas fa-user"></i> &nbsp;<a class="has-link-grey" rel="author" href="https://duinomaker.top/">duinomaker</a></span></div></div><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"> 1.2 过程与它们所产生的计算</h1><div class="content has-math"><style>.article .title,.article h1,.article h2,.article h3,.article h4,.article h5,.article h6{font-family:"Microsoft YaHei",sans-serif}</style><hr><h2 id="Exercise-1-9"><a href="#Exercise-1-9" class="headerlink" title="Exercise 1.9"></a>Exercise 1.9</h2><p>情形一，递归计算</p><pre><code>(+ 4 5)
(inc (+ (dec 4) 5))
(inc (inc (+ (dec 3) 5)))
(inc (inc (inc (+ (dec 2) 5))))
(inc (inc (inc (inc (+ (dec 1) 5)))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
</code></pre><p>情形二，迭代计算</p><pre><code>(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
</code></pre><h2 id="Exercise-1-10"><a href="#Exercise-1-10" class="headerlink" title="Exercise 1.10"></a>Exercise 1.10</h2><pre><code>1024, 65536, 65536
</code></pre><p>$f(n)=2n$<br>$g(n)=2^n$<br>$h(n)=2^{2^{2^{\cdot^{\cdot^\cdot}}}}(\text{共有}\,n\,\text{个}\,2)$</p><h2 id="Exercise-1-11"><a href="#Exercise-1-11" class="headerlink" title="Exercise 1.11"></a>Exercise 1.11</h2><p>递归计算</p><pre><code>(define (f n)
  (if (&lt; n 3)
       n
       (+ (f (- n 1))
          (f (- n 2))
          (f (- n 3)))))
</code></pre><p>迭代计算</p><pre><code>(define (f-iter n)
  (define (f-impl n a b c)
    (if (= n 0) 
        a
        (f-impl (- n 1) b c (+ a b c))))
  (f-impl n 0 1 2))
</code></pre><h2 id="Exercise-1-12"><a href="#Exercise-1-12" class="headerlink" title="Exercise 1.12"></a>Exercise 1.12</h2><pre><code>(define (pascal row col)
  (if (or (= col 0) (= row col))
      1
      (+ (pascal (- row 1) (- col 1))
         (pascal (- row 1) col))))
</code></pre><h2 id="Exercise-1-13"><a href="#Exercise-1-13" class="headerlink" title="Exercise 1.13"></a>Exercise 1.13</h2><p>首先，从 Fibonacci 的定义开始：</p><p>$${\rm Fib}(n)={\rm Fib}(n-1)+{\rm Fib}(n-2)$$</p><p>若假设成立，则将 ${\rm Fib}(n)=\frac{\phi^n-\psi^n}{\sqrt5}$ 代入式中，得出：</p><p>$$\begin{aligned}\frac{\phi^n-\psi^n}{\sqrt5}=\frac{\phi^{n-1}-\psi^{n-1}}{\sqrt5}+\frac{\phi^{n-2}-\psi^{n-2}}{\sqrt5}\\\phi^n-\psi^n=\phi^n\left(\frac1\phi+\frac1{\phi^2}\right)-\psi^n\left(\frac1\psi+\frac1{\psi^2}\right)\end{aligned}$$</p><p>由 $\phi=\frac{1+\sqrt5}{2}$ 和 $\psi=\frac{1-\sqrt5}{2}$ 可知：</p><p>$$\frac1\phi+\frac1{\phi^2}=1,\;\frac1\psi+\frac1{\psi^2}=1$$</p><p>代回上式，算式左右两边相等，所以假设成立。接下来将其拆开：</p><p>$$\begin{aligned}{\rm Fib}(n)=\frac{\phi^n-\psi^n}{\sqrt5}=\frac{\phi^n}{\sqrt5}-\frac{\psi^n}{\sqrt5}\\\frac{\phi^n}{\sqrt5}={\rm Fib}(n)+\frac{\psi^n}{\sqrt5}\end{aligned}$$</p><p>要证明 ${\rm Fib}(n)$ 是与 $\frac{\phi^n}{\sqrt5}$ 最接近的整数，只需证明 $\left|\frac{\psi^n}{\sqrt5}\right|&lt;\frac1{2}$ 对于一切非负整数 $n$ 成立：</p><p>首先，归纳基础 $\left|\frac{\psi^0}{\sqrt5}\right|\approx0.447&lt;\frac1{2}$ 成立。</p><p>假设 $\left|\frac{\psi^{n-1}}{\sqrt5}\right|&lt;\frac1{2}$ 成立，而 $\left|\frac{\psi^n}{\sqrt5}\right|=\left|\frac{\psi^{n-1}}{\sqrt5}\right|\cdot|\psi|$&hairsp;。因为 $|\psi|&lt;1$，所以 $\left|\frac{\psi^n}{\sqrt5}\right|&lt;\left|\frac{\psi^{n-1}}{\sqrt5}\right|&lt;\frac1{2}$&hairsp;。所以 $\left|\frac{\psi^n}{\sqrt5}\right|&lt;\frac1{2}$ 对于一切非负整数 $n$ 成立。</p><p>所以 ${\rm Fib}(n)$ 是与 $\frac{\phi^n}{\sqrt5}$ 最接近的整数，证毕。</p><h2 id="Exercise-1-14"><a href="#Exercise-1-14" class="headerlink" title="Exercise 1.14"></a>Exercise 1.14</h2><p>递归过程中只需要记录该节点之上的节点信息，所以需要的空间与调用树的最大深度成正比。</p><p><code>(cc amount kinds)</code> 节点包含着种类数不变而零钱量减少某个常数的节点，其以下部分的最大深度显然与 <code>amount</code> 成正比，所以空间为 $\Theta(n)$&hairsp;。</p><p>考虑 <code>(cc n 0)</code> 的情况，由于是叶子节点，所需时间为 $\Theta(1)$&hairsp;；<br>再看 <code>(cc n 1)</code> 的情况，其下方有一条像链一样连接着的，从 <code>(cc (- n 1) 1)</code> 直至 <code>(cc 0 1)</code> 的 $n$ 个节点，而这些节点又额外地包含了一个形如 <code>(cc x 0)</code>&hairsp;、所需时间为 $\Theta(1)$ 的节点。所以这时的所需时间为 $\Theta(n)$&hairsp;；<br>接下来，<code>(cc n 2)</code>&hairsp;、<code>(cc n 3)</code> 等的情况，可以仿照 <code>(cc n 1)</code> 的情况来分析，<code>kinds</code> 每增加 $1$，所需时间就得 “乘上一个 $n$”。</p><p>综上所述，有 $k$ 种货币时，时间为 $\Theta(n^k)$&hairsp;。</p><h2 id="Exercise-1-15"><a href="#Exercise-1-15" class="headerlink" title="Exercise 1.15"></a>Exercise 1.15</h2><p>a. <code>p</code> 被调用了 $5$ 次。<br>b. 空间增长为 $\Theta(\log n)$ 阶，时间增长也为 $\Theta(\log n)$ 阶。</p><h2 id="Exercide-1-16"><a href="#Exercide-1-16" class="headerlink" title="Exercide 1.16"></a>Exercide 1.16</h2><pre><code>(define (fast-expt b n)
  (define (fast-expt-impl ans tmp m)
    (if (= m 0)
        ans
        (if (even? m)
            (fast-expt-impl ans (square tmp) (/ m 2))
            (fast-expt-impl (* ans tmp) tmp (- m 1)))))
  (fast-expt-impl 1 b n))
</code></pre><h2 id="Exercise-1-17"><a href="#Exercise-1-17" class="headerlink" title="Exercise 1.17"></a>Exercise 1.17</h2><pre><code>(define (double x) (+ x x))
(define (halve x) (/ x 2))

(define (mul a b)
  (if (= b 0)
      0
      (if (even? b)
          (mul (double a) (halve b))
          (+ a (mul a (- b 1))))))
</code></pre><h2 id="Exercise-1-18"><a href="#Exercise-1-18" class="headerlink" title="Exercise 1.18"></a>Exercise 1.18</h2><pre><code>(define (double x) (+ x x))
(define (halve x) (/ x 2))

(define (mul a b)
  (define (mul-impl ans tmp m)
    (if (= m 0)
        ans
        (if (even? m)
            (mul-impl ans (double tmp) (halve m))
            (mul-impl (+ ans tmp) tmp (- m 1)))))
  (mul-impl 0 a b))
</code></pre><h2 id="Exercise-1-19"><a href="#Exercise-1-19" class="headerlink" title="Exercise 1.19"></a>Exercise 1.19</h2><pre><code>(define (fib n)
  (fib-iter 1 0 0 1 n))
(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   (+ (* p p) (* q q))
                   (+ (* q q) (* p q 2))
                   (/ count 2)))
        (else
         (fib-iter (+ (* b q) (* a q) (* a p))
                   (+ (* b p) (* a q))
                   p
                   q
                   (- count 1)))))
</code></pre><h2 id="Exercise-1-20"><a href="#Exercise-1-20" class="headerlink" title="Exercise 1.20"></a>Exercise 1.20</h2><p>应用序求值</p><pre><code>(gcd 206 40)
(gcd 40 (remainder 206 40))
(gcd 6 (remainder 40 6))
(gcd 4 (remainder 6 4))
(gcd 2 (remainder 4 2))
(gcd 2 0)
2
</code></pre><p><code>remainder</code> 一共被调用了 $4$ 次。</p><p>正则序求值</p><pre><code>(gcd 206 40)
(if (= 40 0) ...)
(gcd 40 (remainder 206 40))
(if (= (remainder 206 40) 0) ...)
(if (= 6 0) ...)
(gcd (remainder 206 40) (remainder 40 (remainder 206 40)))
(if (= (remainder 40 (remainder 206 40)) 0) ...)
(if (= 4 0) ...)
(gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))
(if (= (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) 0) ...)
(if (= 2 0) ...)
(gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))
(if (= (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) 0) ...)
(if (= 0 0) ...)
(remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
2
</code></pre><p><code>remainder</code> 一共被调用了 $18$ 次：$14$ 次用在条件判断中，$4$ 次用在最后的计算中。</p><p>正则序求值最后用于计算的调用次数，等于应用序求值的总调用次数。接下来只需要分析用于条件判断的调用次数。</p><p>将第 $n$ 条 <code>if</code> 表达式的条件部分中 <code>remainder</code> 的出现次数记作 $f(n)$，可以发现</p><p>$$\begin{aligned}f(0)&amp;=0,\;f(1)=1\\f(n)&amp;=f(n-1)+f(n-2)+1\end{aligned}$$</p><p>稍加推导，可以发现</p><p>$$\begin{aligned}f(n)-f(n-1)&amp;={\rm Fib}(n)\\f(n)&amp;=\sum_{i=0}^n{\rm Fib}(i)\\f(n)&amp;={\rm Fib}(n+2)-1\end{aligned}$$</p><p>设 <code>remainder</code> 在应用序求值中的总调用次数为 $n$，在正则序求值中的总调用次数为 ${\rm R}(n)$，可以得出</p><p>$$\begin{aligned}{\rm R}(n)&amp;=n+\sum_{i=0}^nf(i)\\{\rm R}(n)&amp;={\rm Fib}(n+4)-3\end{aligned}$$</p><p>本题中 ${\rm R}(4)=18$，由此可以看出正则序求值可能造成大量的冗余计算。</p><h2 id="Exercise-1-21"><a href="#Exercise-1-21" class="headerlink" title="Exercise 1.21"></a>Exercise 1.21</h2><pre><code>199, 1999, 7
</code></pre><h2 id="Exercise-1-22"><a href="#Exercise-1-22" class="headerlink" title="Exercise 1.22"></a>Exercise 1.22</h2><p>不得不吐槽书中的程序，实在不好用，所以自己重写了一个，正好后面几题也用得到：</p><pre><code>(define (report-time start-time) 
  (display (- (runtime) start-time))
  (newline))
(define (conditional-time-report pred-proc p1)
  (define (timer start-time)
    (cond ((pred-proc p1) (report-time start-time) #t)
          (else #f)))
  (timer (runtime)))
(define (search-for-primes num cnt)
  (if (&gt; cnt 0)
      (if (conditional-time-report prime? num)
          (search-for-primes (+ num 2) (- cnt 1))
          (search-for-primes (+ num 2) cnt))))
(search-for-primes &lt;an odd number to start with&gt; &lt;how many prime numbers before stop&gt;)
</code></pre><p>$n$ 每增加 $4$ 倍，运行时间大约增加 $2$ 倍，这可以粗略地验证该算法的增长阶为 $\Theta(\sqrt n)$&hairsp;。</p><h2 id="Exercise-1-23"><a href="#Exercise-1-23" class="headerlink" title="Exercise 1.23"></a>Exercise 1.23</h2><p>时间大约是原来的一半多一些：一半因为要测试的数减少了约一半，多一些是因为一个额外的 <code>if</code> 语句。</p><h2 id="Exercise-1-24"><a href="#Exercise-1-24" class="headerlink" title="Exercise 1.24"></a>Exercise 1.24</h2><p>增长得比预期更快。这是因为，基本操作的所需时间，会随着数字规模的增大而增加的。而这时，我们得出增长阶为 $\Theta(\log n)$ 的假设——基本操作需要常数时间——失效了。</p><h2 id="Exercise-1-25"><a href="#Exercise-1-25" class="headerlink" title="Exercise 1.25"></a>Exercise 1.25</h2><p>对是对，但这样做会产生巨大的中间数，从而需要大量时间来处理大数。</p><h2 id="Exercise-1-26"><a href="#Exercise-1-26" class="headerlink" title="Exercise 1.26"></a>Exercise 1.26</h2><p>用两次递归调用代替了原来的平方，现在的 <code>expmod</code> 呈现树形递归，计算树形递归的所需时间根据树高呈指数增长。这里树高为 $\log(n)$，那么增长阶为 $\Theta(e^{\log n})=\Theta(n)$&hairsp;。</p><h2 id="Exercise-1-27"><a href="#Exercise-1-27" class="headerlink" title="Exercise 1.27"></a>Exercise 1.27</h2><pre><code>(define (full-fermat-test n)
  (define (test-it a)
    (= (expmod a n n) a))
  (define (test-impl m)
    (cond ((= m n) #t)
          ((test-it m) (test-impl (+ m 1)))
          (else #f)))
  (test-impl 1))
(full-fermat-test 561)
(full-fermat-test 1105)
(full-fermat-test 1729)
...
(prime? 561)
(prime? 1105)
(prime? 1729)
...
</code></pre><p>用 <code>prime?</code> 确定它们都不是素数，但 “骗过” 了所有费马测试。</p><h2 id="Exercise-1-28"><a href="#Exercise-1-28" class="headerlink" title="Exercise 1.28"></a>Exercise 1.28</h2><p>这题有些难度，用到了一个结论：若存在 $1\lt a\lt n-1$，使得 $a^2\equiv 1\;({\rm mod}\;n)$ 成立，则 $n$ 不是素数。</p><p>证明这个结论，需要证明若 $n$ 是素数，则 $x_1=1,x_2=n-1$ 是 $x^2\equiv1\;({\rm mod}\;n)$ 仅有的两个解：</p><p>$$\begin{aligned}\begin{aligned}x^2&amp;\equiv1\;({\rm mod}\;n)\\x^2-1&amp;\equiv0\;({\rm mod}\;n)\\(x-1)(x+1)&amp;\equiv0\;({\rm mod}\;n)\end{aligned}\\\begin{aligned}&amp;\therefore n\mid(x-1)\;\text{或}\;n\mid(x+1)\\&amp;\because n\;\text{是素数}\;\therefore(x-1)\;\text{或}\;(x+1)\;\text{是}\;n\;\text{的倍数}\\&amp;\therefore x_1=1,x_2=n-1\end{aligned}\end{aligned}$$</p><p>若 $1\lt a\lt n-1$ 是其解，则称 $a$ 为 $n$ 的 非平凡平方根&hairsp;$($<em>$\textit{nontrivial square root}$</em>$)$&hairsp;。若 $n$ 有非平凡平方根，则其不是素数。</p><p>这题用到了另一个技巧，修改了 <code>expmod</code> 过程，使其在找到非平凡平方根后返回 $0$&hairsp;。这样一来，一旦过程中出现非平凡平方根，整个 <code>expmod</code> 的值将是 $0$，便于之后的判断。为了理解这一点，我整理了<a href="/posts/miller-rabin/">$\text{Miller–Rabin}$素性测试的原理及实现</a>。</p><pre><code>(define (square x) (* x x))

(define (miller-rabin-expmod base ex n)
  (define (squaremod-with-check x)
    (define (check squaremod-x)
      (if (and (= squaremod-x 1)
               (not (= x 1))
               (not (= x (- n 1))))
          0
          squaremod-x))
    (check (remainder (* x x) n)))
  (cond ((= ex 0) 1)
        ((even? ex)
         (squaremod-with-check (miller-rabin-expmod base (/ ex 2) n)))
        (else
         (remainder (* base (miller-rabin-expmod base (- ex 1) n)) n))))

(define (miller-rabin-test n rounds)
  (define (test-it a)
    (define (test-impl expmod-a)
      (= expmod-a 1))
    (test-impl (miller-rabin-expmod a (- n 1) n)))
  (cond ((= rounds 0) #t)
        ((test-it (+ 1 (random (- n 1))))
         (miller-rabin-test n (- rounds 1)))
        (else #f)))
</code></pre></div></div></div><div class="card"><div class="card-content"><h3 class="title is-5 has-text-weight-normal">Comments</h3><div id="valine-thread" class="content"></div><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>new Valine({el:"#valine-thread",notify:!1,verify:!1,app_id:"jUDJCYuOij3UzEzFmRpQer5U-gzGzoHsz",app_key:"h2AVOMeF8QsLYFdVVbbf9d7k",placeholder:"Suggestions are welcome.",lang:"en"})</script></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start has-text-centered-mobile has-mb-6-mobile"><p>This work is licensed under a <a rel="license noopener external nofollow noreferrer" title="Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">Creative Commons License</a></p></div><div class="level-end has-text-centered-mobile has-mb-5-mobile"><p class="is-size-7">&copy;&nbsp;2020<span style="padding-left:.06em">–</span>2023&nbsp;duinomaker<span>&nbsp;&nbsp;|&nbsp;&nbsp;</span><i class="fas fa-file-word"></i>&nbsp;57.5k&nbsp;words in total<span>&nbsp;&nbsp;|&nbsp;&nbsp;</span><a class="has-link-black-ter" rel="license noopener external nofollow noreferrer" title="Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank"><i class="fab fa-creative-commons"></i>&nbsp;&nbsp;<i class="fab fa-creative-commons-by"></i>&nbsp;&nbsp;<i class="fab fa-creative-commons-nc"></i>&nbsp;&nbsp;<i class="fab fa-creative-commons-sa"></i></a></p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script>var IcarusThemeSettings={site:{url:"https://duinomaker.top",external_link:{enable:!0,exclude:[]}},article:{highlight:{clipboard:!1,fold:"unfolded"}}}</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js" defer="defer"></script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/auto-render.min.js" defer="defer"></script><script>document.addEventListener("DOMContentLoaded",function(){for(contents=document.getElementsByClassName("has-math"),i=0;i<contents.length;++i)renderMathInElement(contents[i],{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script src="/assets/main.js" defer="defer"></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"> <input type="text" class="searchbox-input ins-search-input" placeholder="Type something..."><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)"},CONTENT_URL:"/assets/content.json"}</script><script src="/assets/insight.js" defer="defer"></script><link rel="stylesheet" href="/assets/search.css"><link rel="stylesheet" href="/assets/insight.css"></body></html>