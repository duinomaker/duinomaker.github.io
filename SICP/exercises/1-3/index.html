<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 6.3.0"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="format-detection" content="telephone=no"><title>1.3 用高阶函数做抽象 - duinomaker&#39;s blog</title><meta name="description" content="Solutions to exercises in SICP section 1.3 - Formulating Abstractions with Higher-Order Procedures"><meta property="og:type" content="website"><meta property="og:title" content="1.3 用高阶函数做抽象"><meta property="og:url" content="https://duinomaker.top/SICP/exercises/1-3/"><meta property="og:site_name" content="duinomaker&#39;s blog"><meta property="og:description" content="Solutions to exercises in SICP section 1.3 - Formulating Abstractions with Higher-Order Procedures"><meta property="og:locale"><meta property="og:image" content="https://duinomaker.top/images/og_image.png"><meta property="article:published_time" content="2020-04-09T15:10:45.000Z"><meta property="article:modified_time" content="2021-03-21T08:17:57.000Z"><meta property="article:author" content="duinomaker"><meta property="article:tag" content="mathematics"><meta property="article:tag" content="programming"><meta property="article:tag" content="algorithm"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://duinomaker.top/images/og_image.png"><meta name="twitter:creator" content="@duinomaker"><meta name="twitter:site" content="@duinomaker"><meta property="fb:admins" content="100043022235251"><link rel="canonical" href="https://duinomaker.top/SICP/exercises/1-3/"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin="anonymous"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="apple-touch-icon" type="image/png" sizes="57x57" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" type="image/png" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" type="image/png" sizes="72x72" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" type="image/png" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="icon" type="image/svg+xml" href="/images/favicon.svg"><link rel="alternate icon" type="image/png" href="/images/favicon.png"><link rel="shortcut icon" type="image/x-icon" sizes="32x32" href="/images/favicon-32x32.ico"><link rel="shortcut icon" type="image/x-icon" sizes="16x16" href="/images/favicon-16x16.ico"><link rel="preload" href="/assets/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous"><link rel="preload" href="/assets/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@latest/css/bulma.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,italic,500,500italic|Source+Code+Pro|Alegreya:400,italic,500,500italic"><link rel="stylesheet" href="/assets/font-awesome/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@latest/styles/atom-one-light.min.css"><link rel="stylesheet" href="/assets/style.css"></head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand is-flex-center"> <a class="navbar-item navbar-logo" href="/"><img src="/images/misc/logo.svg" alt="1.3 用高阶函数做抽象" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"> <a class="navbar-item" href="/">Home</a> <a class="navbar-item" href="/archives/">Archives</a> <a class="navbar-item" href="/categories/">Categories</a> <a class="navbar-item" href="/notes/">Notes</a> <a class="navbar-item" href="/about/">About</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;" rel="external nofollow noreferrer"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column is-12 has-order-2 column-main"><div class="card"><div class="card-content article"><div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto"><div class="level-left"> <time class="level-item has-text-grey" datetime="2020-04-09T15:10:45.000Z">April 09, 2020</time><span class="level-item has-text-grey"><i class="fas fa-user"></i> &nbsp;<a class="has-link-grey" rel="author" href="https://duinomaker.top/">duinomaker</a></span></div></div><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"> 1.3 用高阶函数做抽象</h1><div class="content has-math"><style>.article .title,.article h1,.article h2,.article h3,.article h4,.article h5,.article h6{font-family:"Microsoft YaHei",sans-serif}</style><hr><h2 id="Exercise-1-29"><a href="#Exercise-1-29" class="headerlink" title="Exercise 1.29"></a>Exercise 1.29</h2><p>为了避免 <code>h</code> 被重复求值多次，我在最外层定义了一个 <code>h-equals</code>，也就是将已经求出的值绑定给了 <code>h</code>&hairsp;。这就有点像赋值操作了，而函数式编程范式一个重要的特点却是 “无状态性”。是不是偏离了原本的意图呢？有些费解。</p><pre><code>(define (simpson f a b n)
  (define (h-equals h)
    (define (term k)
      (define (coef k)
        (cond ((or (= k 0) (= k n)) 1)
              ((even? k) 2)
              (else 4)))
      (* (coef k) (f (+ a (* k h)))))
    (define (next k) (+ k 1))
    (* (sum term 0 next n) (/ h 3)))
  (h-equals (/ (- b a) n)))
</code></pre><h2 id="Exercise-1-30"><a href="#Exercise-1-30" class="headerlink" title="Exercise 1.30"></a>Exercise 1.30</h2><pre><code>(define (sum term a next b)
  (define (iter a result)
    (if (&gt; a b)
        result
        (iter (next a) (+ result (term a)))))
  (iter a 0))
</code></pre><h2 id="Exercise-1-31"><a href="#Exercise-1-31" class="headerlink" title="Exercise 1.31"></a>Exercise 1.31</h2><p>这里为了方便，<code>pi-approx</code> 将两项合并为一项来计算了，大概不算犯规吧。</p><pre><code>(define (square x) (* x x))

(define (product term a next b)
  (define (iter a result)
    (if (&gt; a b)
        result
        (iter (next a) (* result (term a)))))
  (iter a 1))

(define (factorial n)
  (define (self x) x)
  (define (next x) (+ x 1))
  (product self 1 next n))

(define (pi-approx n)
  (define (term x)
    (* (/ (* (+ 2 (* x 2)) (+ 4 (* x 2))) 
          (square (+ 3 (* x 2))))
       1.0))
  (define (next x) (+ x 1))
  (* (product term 0 next n) 4))
</code></pre><h2 id="Exercise-1-32"><a href="#Exercise-1-32" class="headerlink" title="Exercise 1.32"></a>Exercise 1.32</h2><pre><code>(define (accumulate combiner null-value term a next b)
  (if (&gt; a b)
      null-value
      (combiner (term a)
                (accumulate combiner null-value term (next a) next b))))

(define (accumulate-iter combiner null-value term a next b)
  (define (iter a result)
    (if (&gt; a b)
        result
        (iter (next a) (combiner (term a) result))))
  (iter a null-value))
</code></pre><h2 id="Exercise-1-33"><a href="#Exercise-1-33" class="headerlink" title="Exercise 1.33"></a>Exercise 1.33</h2><pre><code>(define (filtered-accumulate filter combiner null-value term a next b)
  (define (iter a result)
    (if (&gt; a b)
        result
        (if (filter a)
            (iter (next a) (combiner (term a) result))
            (iter (next a) result))))
  (iter a null-value))

(define (coprime? a b)
  (= (gcd a b) 1))

(define (sum-primes a b)
  (define (next x) (+ x 1))
  (filtered-accumulate prime? + 0 square a next b))

(define (sum-coprimes n)
  (define (coprime-with-n? x) (coprime? n x))
  (define (next x) (+ x 1))
  (define (self x) x)
  (filtered-accumulate coprime-with-n? + 0 self 1 next (- n 1)))
</code></pre><h2 id="Exercise-1-34"><a href="#Exercise-1-34" class="headerlink" title="Exercise 1.34"></a>Exercise 1.34</h2><p>演变过程是这样的：</p><pre><code>(f f)
(f 2)
(2 2)
</code></pre><p>对 <code>(2 2)</code> 求值就会出错，本来应该放置过程的位置是 <code>2</code>，而它不是一个过程。</p><h2 id="Exercise-1-35"><a href="#Exercise-1-35" class="headerlink" title="Exercise 1.35"></a>Exercise 1.35</h2><pre><code>(define golden-ratio
  (fixed-point (lambda (x) (+ 1.0 (/ 1.0 x))) 1.0))
</code></pre><p>正确地逼近了黄金分割比例的值。</p><h2 id="Exercise-1-36"><a href="#Exercise-1-36" class="headerlink" title="Exercise 1.36"></a>Exercise 1.36</h2><pre><code>(define (root-x-pow-x start-point)
  (fixed-point (lambda (x) (/ (log 1000) (log x))) start-point 0))

(define (root-x-pow-x-with-damp start-point)
  (define (damp-func x)
    (/ (+ x (/ (log 1000) (log x))) 2.0))
  (fixed-point damp-func start-point 0))

(root-x-pow-x 3.0)
(root-x-pow-x 10.0)
(root-x-pow-x-with-damp 3.0)
(root-x-pow-x-with-damp 10.0)
</code></pre><p>阻尼法所需的迭代步数更少。</p><h2 id="Exercise-1-37"><a href="#Exercise-1-37" class="headerlink" title="Exercise 1.37"></a>Exercise 1.37</h2><pre><code>(define (cont-frac n d k)
  (define (frac-transform term k)
    (/ (n k) (+ (d k) term)))
  (define (rec i)
    (if (&gt; i k)
        0.0
        (frac-transform (rec (+ i 1)) i)))
  (rec 1))

(define (cont-frac-iter n d k)
  (define (frac-transform term k)
    (/ (n k) (+ (d k) term)))
  (define (iter result k)
    (if (= k 0)
        result
        (iter (frac-transform result k) (- k 1))))
  (iter 0.0 k))

(cont-frac      (lambda (x) 1.0) (lambda (x) 1.0) 11)
(cont-frac-iter (lambda (x) 1.0) (lambda (x) 1.0) 11)
</code></pre><p>为了达到 $4$ 位小数的精度，需要十几步计算。</p><h2 id="Exercise-1-38"><a href="#Exercise-1-38" class="headerlink" title="Exercise 1.38"></a>Exercise 1.38</h2><pre><code>(define (approx-e k)
  (define (arr n)
    (let ((t (+ n 1)))
      (if (= (remainder t 3) 0)
          (* (/ t 3) 2.0)
          1.0)))
  (+ (cont-frac (lambda (x) 1.0) arr k) 2))
</code></pre><h2 id="Exercise-1-39"><a href="#Exercise-1-39" class="headerlink" title="Exercise 1.39"></a>Exercise 1.39</h2><pre><code>(define (tan-cf x k)
  (let ((minus-x2 (- (* x x))))
    (define (n k) (if (= k 1) x minus-x2))
    (define (d k) (* (- (* k 2) 1) 1.0))
    (cont-frac n d k)))
</code></pre><h2 id="Exercise-1-40"><a href="#Exercise-1-40" class="headerlink" title="Exercise 1.40"></a>Exercise 1.40</h2><pre><code>(define (cubic a b c)
  (lambda (x)
    (+ (* x x x) (* a x x) (* b x) c)))
</code></pre><h2 id="Exercise-1-41"><a href="#Exercise-1-41" class="headerlink" title="Exercise 1.41"></a>Exercise 1.41</h2><pre><code>(define (double f)
  (lambda (x) (f (f x))))

(((double (double double)) inc) 5)
</code></pre><p>输出了 $21$，因为 <code>inc</code> 外面嵌套了 $4$ 个 <code>double</code>，所以一共增加了 $2^4=16$ 次。</p><h2 id="Exercise-1-42"><a href="#Exercise-1-42" class="headerlink" title="Exercise 1.42"></a>Exercise 1.42</h2><pre><code>(define (compose f g)
  (lambda (x) (f (g x))))
</code></pre><h2 id="Exercise-1-43"><a href="#Exercise-1-43" class="headerlink" title="Exercise 1.43"></a>Exercise 1.43</h2><pre><code>(define (repeated f times)
  (lambda (x)
    (cond ((= times 0) x)
          ((even? times)
           ((double (repeated f (/ times 2))) x))
          (else
           ((compose f (repeated f (- times 1))) x)))))
</code></pre><h2 id="Exercise-1-44"><a href="#Exercise-1-44" class="headerlink" title="Exercise 1.44"></a>Exercise 1.44</h2><pre><code>(define (n-fold f n dx)
  (define (smooth f)
    (lambda (x)
      (/ (+ (f (- x dx))
            (f x)
            (f (+ x dx)))
         3)))
  ((repeated smooth n) f))
</code></pre><h2 id="Exercise-1-45"><a href="#Exercise-1-45" class="headerlink" title="Exercise 1.45"></a>Exercise 1.45</h2><pre><code>(define (log2-ceil n)
  (define (iter x ord)
    (if (&lt; x n)
        (iter (* x 2) (+ ord 1))
        ord))
  (iter 1 0))

(define (root-find n ord)
  (fixed-point-of-transform (lambda (x) (/ n (expt x (- ord 1))))
                            (repeated average-damp
                                      (log2-ceil ord))
                            1.0))
</code></pre><p>计算 $n$ 次根号，需要将 <code>average-damp</code> 重复应用 $\lceil\log_2n\rceil$ 次。</p><h2 id="Exercise-1-46"><a href="#Exercise-1-46" class="headerlink" title="Exercise 1.46"></a>Exercise 1.46</h2><pre><code>(define (iterative-improve good-enough? improve initial-guess)
  (define (iter guess)
    (let ((next (improve guess)))
      (if (good-enough? guess next)
          next
          (iter next))))
  (iter initial-guess))

(define (good-enough? a b)
  (&lt; (abs (- a b)) 0.00001))

(define (sqrt n)
  (define (improve x)
    (/ (+ x (/ n x)) 2.0))
  (iterative-improve good-enough? improve 1.0))

(define (fixed-point f guess)
  (iterative-improve good-enough? f guess))
</code></pre></div></div></div><div class="card"><div class="card-content"><h3 class="title is-5 has-text-weight-normal">Comments</h3><div id="valine-thread" class="content"></div><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>new Valine({el:"#valine-thread",notify:!1,verify:!1,app_id:"jUDJCYuOij3UzEzFmRpQer5U-gzGzoHsz",app_key:"h2AVOMeF8QsLYFdVVbbf9d7k",placeholder:"Suggestions are welcome.",lang:"en"})</script></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start has-text-centered-mobile has-mb-6-mobile"><p>This work is licensed under a <a rel="license noopener external nofollow noreferrer" title="Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">Creative Commons License</a></p></div><div class="level-end has-text-centered-mobile has-mb-5-mobile"><p class="is-size-7">&copy;&nbsp;2020<span style="padding-left:.06em">–</span>2023&nbsp;duinomaker<span>&nbsp;&nbsp;|&nbsp;&nbsp;</span><i class="fas fa-file-word"></i>&nbsp;57.5k&nbsp;words in total<span>&nbsp;&nbsp;|&nbsp;&nbsp;</span><a class="has-link-black-ter" rel="license noopener external nofollow noreferrer" title="Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank"><i class="fab fa-creative-commons"></i>&nbsp;&nbsp;<i class="fab fa-creative-commons-by"></i>&nbsp;&nbsp;<i class="fab fa-creative-commons-nc"></i>&nbsp;&nbsp;<i class="fab fa-creative-commons-sa"></i></a></p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script>var IcarusThemeSettings={site:{url:"https://duinomaker.top",external_link:{enable:!0,exclude:[]}},article:{highlight:{clipboard:!1,fold:"unfolded"}}}</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js" defer="defer"></script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/auto-render.min.js" defer="defer"></script><script>document.addEventListener("DOMContentLoaded",function(){for(contents=document.getElementsByClassName("has-math"),i=0;i<contents.length;++i)renderMathInElement(contents[i],{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script src="/assets/main.js" defer="defer"></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"> <input type="text" class="searchbox-input ins-search-input" placeholder="Type something..."><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)"},CONTENT_URL:"/assets/content.json"}</script><script src="/assets/insight.js" defer="defer"></script><link rel="stylesheet" href="/assets/search.css"><link rel="stylesheet" href="/assets/insight.css"></body></html>