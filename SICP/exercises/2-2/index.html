<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hexo 6.3.0"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="format-detection" content="telephone=no"><title>2.2 Hierarchical Data and the Closure Property - duinomaker&#39;s blog</title><meta name="description" content="Solutions to exercises in SICP section 2.2 - Hierarchical Data and the Closure Property"><meta property="og:type" content="website"><meta property="og:title" content="2.2 Hierarchical Data and the Closure Property"><meta property="og:url" content="https://duinomaker.top/SICP/exercises/2-2/"><meta property="og:site_name" content="duinomaker&#39;s blog"><meta property="og:description" content="Solutions to exercises in SICP section 2.2 - Hierarchical Data and the Closure Property"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://duinomaker.top/images/og_image.png"><meta property="article:published_time" content="2020-04-20T15:10:45.000Z"><meta property="article:modified_time" content="2021-03-21T08:17:57.000Z"><meta property="article:author" content="duinomaker"><meta property="article:tag" content="mathematics"><meta property="article:tag" content="programming"><meta property="article:tag" content="algorithm"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://duinomaker.top/images/og_image.png"><meta name="twitter:creator" content="@duinomaker"><meta name="twitter:site" content="@duinomaker"><meta property="fb:admins" content="100043022235251"><link rel="canonical" href="https://duinomaker.top/SICP/exercises/2-2/"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin="anonymous"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="apple-touch-icon" type="image/png" sizes="57x57" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" type="image/png" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" type="image/png" sizes="72x72" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" type="image/png" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="icon" type="image/svg+xml" href="/images/favicon.svg"><link rel="alternate icon" type="image/png" href="/images/favicon.png"><link rel="shortcut icon" type="image/x-icon" sizes="32x32" href="/images/favicon-32x32.ico"><link rel="shortcut icon" type="image/x-icon" sizes="16x16" href="/images/favicon-16x16.ico"><link rel="preload" href="/assets/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous"><link rel="preload" href="/assets/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@latest/css/bulma.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,italic,500,500italic|Source+Code+Pro|Alegreya:400,italic,500,500italic"><link rel="stylesheet" href="/assets/font-awesome/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@latest/styles/atom-one-light.min.css"><link rel="stylesheet" href="/assets/style.css"></head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand is-flex-center"> <a class="navbar-item navbar-logo" href="/"><img src="/images/misc/logo.svg" alt="2.2 Hierarchical Data and the Closure Property" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"> <a class="navbar-item" href="/">Home</a> <a class="navbar-item" href="/archives/">Archives</a> <a class="navbar-item" href="/categories/">Categories</a> <a class="navbar-item" href="/notes/">Notes</a> <a class="navbar-item" href="/about/">About</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;" rel="external nofollow noreferrer"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column is-12 has-order-2 column-main"><div class="card"><div class="card-content article"><div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto"><div class="level-left"> <time class="level-item has-text-grey" datetime="2020-04-20T15:10:45.000Z">April 20, 2020</time><span class="level-item has-text-grey"><i class="fas fa-user"></i> &nbsp;<a class="has-link-grey" rel="author" href="https://duinomaker.top/">duinomaker</a></span></div></div><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal serif"> 2.2 Hierarchical Data and the Closure Property</h1><div class="content has-math serif"><style>strong{font-weight:500}</style><style>.article .content{font-size:1.2rem}</style><hr><h2 id="Exercise-2-17"><a href="#Exercise-2-17" class="headerlink" title="Exercise 2.17"></a>Exercise 2.17</h2><pre><code>(define (last-pair lst)
  (if (null? (cdr lst))
      lst
      (last-pair (cdr lst))))
</code></pre><h2 id="Exercise-2-18"><a href="#Exercise-2-18" class="headerlink" title="Exercise 2.18"></a>Exercise 2.18</h2><pre><code>(define (reverse lst)
  (define (iter lst result)
    (if (null? lst)
        result
        (iter (cdr lst) (cons (car lst) result))))
  (iter lst nil))
</code></pre><h2 id="Exercise-2-19"><a href="#Exercise-2-19" class="headerlink" title="Exercise 2.19"></a>Exercise 2.19</h2><pre><code>(define (no-more? coins)
  (null? coins))
(define (first-denomination coins)
  (car coins))
(define (except-first-denomination coins)
  (cdr coins))
</code></pre><p>The order of denominations doesn’t affect the result. Because both procedures compute all possible combinations.</p><h2 id="Exercise-2-20"><a href="#Exercise-2-20" class="headerlink" title="Exercise 2.20"></a>Exercise 2.20</h2><pre><code>(define (same-parity f . r)
  (define (equiv? a b)
    (or (and a b)
        (and (not a) (not b))))
  (let ((p (even? f)))
    (define (choose r)
      (cond ((null? r) nil)
            ((equiv? p (even? (car r)))
             (cons (car r) (choose (cdr r))))
            (else
             (choose (cdr r)))))
    (cons f (choose r))))
</code></pre><h2 id="Exercise-2-21"><a href="#Exercise-2-21" class="headerlink" title="Exercise 2.21"></a>Exercise 2.21</h2><pre><code>(define (square-list items)
  (if (null? items)
      nil
      (cons (* (car items) (car items))
            (square-list (cdr items)))))
(define (square-list items)
  (map (lambda (x) (* x x)) items))
</code></pre><h2 id="Exercise-2-22"><a href="#Exercise-2-22" class="headerlink" title="Exercise 2.22"></a>Exercise 2.22</h2><p>The first one will generate a reversed result because the first element of <code>items</code> is attached to the front of <code>answer</code> every iteration;</p><p>The latter one doesn’t work because it will finally produce a structure like <code>(((((() . 1) . 2) . 3) . 4) . 5)</code>&hairsp;, which is not even a list.</p><h2 id="Exercise-2-23"><a href="#Exercise-2-23" class="headerlink" title="Exercise 2.23"></a>Exercise 2.23</h2><pre><code>(define (for-each proc items)
  (define (iter items)
    (cond ((not (null? items))
           (proc (car items))
           (iter (cdr items)))))
  (iter items))
</code></pre><h2 id="Exercise-2-24"><a href="#Exercise-2-24" class="headerlink" title="Exercise 2.24"></a>Exercise 2.24</h2><p>The interpreter prints <code>(1 (2 (3 4)))</code>&hairsp;.</p><h2 id="Exercise-2-25"><a href="#Exercise-2-25" class="headerlink" title="Exercise 2.25"></a>Exercise 2.25</h2><pre><code>(car (cdr (car (cdr (cdr lst)))))
(car (car lst))
(car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr lst))))))))))))
</code></pre><h2 id="Exercise-2-26"><a href="#Exercise-2-26" class="headerlink" title="Exercise 2.26"></a>Exercise 2.26</h2><pre><code>(1 2 3 4 5 6)
((1 2 3) 4 5 6)
((1 2 3) (4 5 6))
</code></pre><h2 id="Exercise-2-27"><a href="#Exercise-2-27" class="headerlink" title="Exercise 2.27"></a>Exercise 2.27</h2><pre><code>(define (deep-reverse tree)
  (define (iter tree result)
    (cond ((null? tree) result)
          ((pair? tree)
           (iter (cdr tree)
                 (cons (deep-reverse (car tree))
                       result)))
          (else tree)))
  (iter tree nil))
</code></pre><h2 id="Exercise-2-28"><a href="#Exercise-2-28" class="headerlink" title="Exercise 2.28"></a>Exercise 2.28</h2><p>I made use of the <code>append</code> procedure defined previously.</p><pre><code>(define (fringe tree)
  (cond ((null? tree) nil)
        ((pair? tree)
         (append (fringe (car tree))
                 (fringe (cdr tree))))
        (else (list tree))))
</code></pre><h2 id="Exercise-2-29"><a href="#Exercise-2-29" class="headerlink" title="Exercise 2.29"></a>Exercise 2.29</h2><p>a.</p><pre><code>(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (car (cdr mobile)))
(define (branch-length mobile)
  (car mobile))
(define (branch-structure mobile)
  (car (cdr mobile)))
</code></pre><p>b.</p><pre><code>(define (total-weight object)
  (if (number? object)
      object
      (+ (total-weight (branch-structure (left-branch object)))
         (total-weight (branch-structure (right-branch object))))))
</code></pre><p>c.</p><pre><code>(define (torque branch)
  (* (branch-length branch)
     (total-weight (branch-structure branch))))

(define (balanced? object)
  (or (number? object)
      (and (= (torque (left-branch object))
              (torque (right-branch object)))
           (balanced? (branch-structure (left-branch object)))
           (balanced? (branch-structure (right-branch object))))))
</code></pre><p>d.</p><pre><code>(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (cdr mobile))
(define (branch-length mobile)
  (car mobile))
(define (branch-structure mobile)
  (cdr mobile))
</code></pre><p>Only four procedures have to be changed. That’s the convenience abstraction barriers bring to us.</p><h2 id="Exercise-2-30"><a href="#Exercise-2-30" class="headerlink" title="Exercise 2.30"></a>Exercise 2.30</h2><pre><code>(define (square-tree tree)
  (cond ((null? tree) nil)
        ((pair? tree)
         (cons (square-tree (car tree))
               (square-tree (cdr tree))))
        (else (* tree tree))))
</code></pre><h2 id="Exercise-2-31"><a href="#Exercise-2-31" class="headerlink" title="Exercise 2.31"></a>Exercise 2.31</h2><pre><code>(define (tree-map proc tree)
  (cond ((null? tree) nil)
        ((pair? tree)
         (cons (tree-map proc (car tree))
               (tree-map proc (cdr tree))))
        (else (proc tree))))
</code></pre><p>Another solution uses <code>map</code>&hairsp;:</p><pre><code>(define (tree-map proc tree)
  (map (lambda (subtree)
              (cond ((null? subtree) nil)
                    ((pair? subtree)
                     (tree-map proc subtree))
                    (else (proc subtree))))
            tree))
</code></pre><h2 id="Exercise-2-32"><a href="#Exercise-2-32" class="headerlink" title="Exercise 2.32"></a>Exercise 2.32</h2><pre><code>(define (subset s)
  (if (null? s)
      (list nil)
      (let ((rest (subset (cdr s))))
        (append rest
                (map (lambda (lst)
                       (cons (car s) lst))
                     rest)))))
</code></pre><p>Initially I wrongly wrote <code>nil</code> instead of <code>(list nil)</code>&hairsp;, which always generates an empty list.</p><p>It works, because the set of all subsets is a union of:</p><ul><li>The set of all subsets excluding the first number;</li><li>The set of all subsets excluding the first number that has the first number re-inserted into each subset.</li></ul><h2 id="Exercise-2-33"><a href="#Exercise-2-33" class="headerlink" title="Exercise 2.33"></a>Exercise 2.33</h2><pre><code>(define (map proc seq)
  (accumulate (lambda (x y)
                (cons (proc x) y))
              nil
              seq))
(define (append seq1 seq2)
  (accumulate cons seq2 seq1))
(define (length seq)
  (accumulate (lambda (x y) (+ y 1)) 0 seq))
</code></pre><h2 id="Exercise-2-34"><a href="#Exercise-2-34" class="headerlink" title="Exercise 2.34"></a>Exercise 2.34</h2><pre><code>(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms)
                (+ (* higher-terms x) this-coeff))
              0
              coefficient-sequence))
</code></pre><h2 id="Exercise-2-35"><a href="#Exercise-2-35" class="headerlink" title="Exercise 2.35"></a>Exercise 2.35</h2><pre><code>(define (count-leaves tree)
  (accumulate
    (lambda (x y)
      (+ (cond ((null? x) 0)
               ((pair? x)
                (count-leaves x))
               (else 1))
         y))
    0
    tree))
</code></pre><h2 id="Exercise-2-36"><a href="#Exercise-2-36" class="headerlink" title="Exercise 2.36"></a>Exercise 2.36</h2><pre><code>(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init (map car seqs))
            (accumulate-n op init (map cdr seqs)))))
</code></pre><p>Another version uses a separately defined <code>transpose</code> procedure:</p><pre><code>(define (transpose seqs)
  (if (null? (car seqs))
      nil
      (cons (map car seqs)
            (transpose (map cdr seqs)))))
(define (accumulate-n op init seqs)
  (map (lambda (x)
         (accumulate op init x))
       (transpose seqs)))
</code></pre><h2 id="Exercise-2-37"><a href="#Exercise-2-37" class="headerlink" title="Exercise 2.37"></a>Exercise 2.37</h2><pre><code>(define (matrix-*-vector m v)
  (map (lambda (x) (dot-product x v)) m))
(define (transpose mat)
  (if (null? (car mat))
      nil
      (cons (map car mat)
            (transpose (map cdr mat)))))
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map (lambda (x) (matrix-*-vector cols x))
         m)))
</code></pre><h2 id="Exercise-2-38"><a href="#Exercise-2-38" class="headerlink" title="Exercise 2.38"></a>Exercise 2.38</h2><pre><code>3/2
1/6
(1 (2 (3 ())))
(((() 1) 2) 3)
</code></pre><p><code>op</code> should have commutativity and associativity simultaneously:</p><p>Commutativity alone is not enough, such as $x\;{\rm op}\;y=x^2+y^2$&hairsp;;</p><p>Associativity alone is not enough, such as matrix multiplications.</p><h2 id="Exercise-2-39"><a href="#Exercise-2-39" class="headerlink" title="Exercise 2.39"></a>Exercise 2.39</h2><pre><code>(define (reverse seq)
  (fold-right (lambda (x y) (append y (list x)))
              nil
              seq))
(define (reverse seq)
  (fold-left (lambda (x y) (cons y x))
             nil
             seq))
</code></pre><h2 id="Exercise-2-40"><a href="#Exercise-2-40" class="headerlink" title="Exercise 2.40"></a>Exercise 2.40</h2><pre><code>(define (unique-pairs n)
  (flatmap (lambda (i)
             (map (lambda (j) (list i j))
                  (enumerate-interval 1 (- i 1))))
           (enumerate-interval 1 n)))
(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum?
               (unique-pairs n))))
</code></pre><h2 id="Exercise-2-41"><a href="#Exercise-2-41" class="headerlink" title="Exercise 2.41"></a>Exercise 2.41</h2><pre><code>(define (make-triples n s)
  (define (eligible? triple)
    (and (&lt; (cadr triple) (caddr triple))
         (&lt;= (caddr triple) n)))
  (filter eligible?
          (flatmap
           (lambda (i)
             (map (lambda (j)
                    (list j i (- s i j)))
             (enumerate-interval 1 (- i 1))))
          (enumerate-interval 2 n))))
</code></pre><h2 id="Exercise-2-42"><a href="#Exercise-2-42" class="headerlink" title="Exercise 2.42"></a>Exercise 2.42</h2><pre><code>(define empty-board nil)
(define (adjoin-position new-row k rest-of-queens)
  (append rest-of-queens (list (list new-row k))))
(define (safe? k positions)
  (define (row-of pos) (car pos))
  (define (col-of pos) (cadr pos))
  (let ((new-queen
         (car (filter (lambda (pos) (= (col-of pos) k))
               positions)))
        (rest-of-queens
         (filter (lambda (pos) (not (= (col-of pos) k)))
          positions)))
    (define (examine unexamined-queens)
      (cond ((null? unexamined-queens) #t)
            ((let ((x1 (row-of (car unexamined-queens)))
                   (y1 (col-of (car unexamined-queens)))
                   (x2 (row-of new-queen))
                   (y2 (col-of new-queen)))
               (or (= (+ x1 y1) (+ x2 y2))
                   (= (+ x1 y2) (+ x2 y1))
                   (= x1 x2)
                   (= y1 y2))) #f)
            (else (examine (cdr unexamined-queens)))))
    (examine rest-of-queens)))

(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position
                    new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
</code></pre><p><span id="two-queens-safe">I also wrote a more abstract version that defines</span></p><pre><code>(define (two-queens-safe? q1 q2)
  (let ((x1 (row-of q1))
        (y1 (col-of q1))
        (x2 (row-of q2))
        (y2 (col-of q2)))
    (not (or (= (+ x1 y1) (+ x2 y2))
             (= (+ x1 y2) (+ x2 y1))
             (= x1 x2)
             (= y1 y2)))))
</code></pre><p>to check whether two queens are safe with respect to each other. And uses</p><pre><code>(accumulate (lambda (another-queen result)
              (and (two-queens-safe? new-queen another-queen)
                   result))
            #t
            rest-of-queens)
</code></pre><p>to replace the original <code>examine</code> procedure. I gave it up thinking that it would sacrifice the readability of my program. But this level of abstraction provides a fundamental basis for the algorithm analyses in <a href="#Exercise-2-43">Exercise 2.43</a>.</p><h2 id="Exercise-2-43"><a href="#Exercise-2-43" class="headerlink" title="Exercise 2.43"></a>Exercise 2.43</h2><p>Exchanging the order of the mapping causes <code>(queen-cols (- k 1))</code> to be invoked for every element in <code>(enumerate-interval 1 board-size)</code>&hairsp;.</p><p>Let’s say that $A_{k,n}$ is the number of all ways to place queens in the first $k$ columns of an $n\times n$ board. For the $8\times8$ case, we have</p><p>$$\begin{array}{r|ccccccccc}k&amp;0&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8\\A_{k,8}&amp;1&amp;8&amp;42&amp;140&amp;344&amp;568&amp;550&amp;312&amp;92\end{array}$$</p><p>Since that <code>two-queens-safe?</code> defined in <a href="#two-queens-safe">Exercise 2.42</a> takes a constant time to determine whether two queens are safe with respect to each other, we stipulate that it is the primitive operation. Let’s say $B_{k,n}$ is the number of times <code>two-queens-safe?</code> to be invoked when calling <code>(queen-cols k)</code> of the original algorithm on an $n\times n$ board. We have the recurrence</p><p>$$B_{k,n}=\begin{cases}0\,,&amp;\text{if $k=0$}\,;\\n(k-1)A_{k-1,n}+B_{k-1,n}\,,&amp;\text{if $k&gt;0$}\,.\end{cases}$$</p><p>In the recurrence above, multiply $A_{k-1,n}$ by $n(k-1)$ means we have to attach $n$ possible new queens to each of ways to place previous queens, and filter each of them, during which the new queen has to be examined with the other $k-1$ queens.</p><p>In the original algorithm, $B_{8,8}=81696$&hairsp;.</p><p>Exchanging the order of mapping causes <code>(queen-cols (- k 1))</code> to be invoked $n$ times instead of once, the recurrence is simply</p><p>$$B^\prime_{k,n}=\begin{cases}0\,,&amp;\text{if $k=0$}\,;\\n(k-1)A_{k-1,n}+nB^\prime_{k-1,n}\,,&amp;\text{if $k&gt;0$}\,.\end{cases}$$</p><p>In Louis’ algorithm, $B^\prime_{8,8}=59878720$&hairsp;, about $733\cdot B_{8,8}$&hairsp;. So the required time is about $733T$&hairsp;.</p><h2 id="Exercise-2-44"><a href="#Exercise-2-44" class="headerlink" title="Exercise 2.44"></a>Exercise 2.44</h2><pre><code>(define (up-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (up-split painter (- n 1))))
        (below painter
               (beside smaller smaller)))))
</code></pre><h2 id="Exercise-2-45"><a href="#Exercise-2-45" class="headerlink" title="Exercise 2.45"></a>Exercise 2.45</h2><pre><code>(define (split proc1 proc2)
  (define (impl painter n)
    (if (= n 0)
        painter
        (let ((smaller (impl painter (- n 1))))
          (proc1 painter
                 (proc2 smaller smaller)))))
  impl)
</code></pre><h2 id="Exercise-2-46"><a href="#Exercise-2-46" class="headerlink" title="Exercise 2.46"></a>Exercise 2.46</h2><pre><code>(define (make-vect xcor ycor) (list xcor ycor))
(define (xcor-vect vect) (car vect))
(define (ycor-vect vect) (cadr vect))
(define (add-vect vect1 vect2)
  (make-vect (+ (xcor-vect vect1) (xcor-vect vect2))
             (+ (ycor-vect vect1) (ycor-vect vect2))))
(define (sub-vect vect1 vect2)
  (make-vect (- (xcor-vect vect1) (xcor-vect vect2))
             (- (ycor-vect vect1) (ycor-vect vect2))))
(define (scale-vect factor vect)
  (make-vect (* (xcor-vect vect) factor)
             (* (ycor-vect vect) factor)))
</code></pre><h2 id="Exercise-2-47"><a href="#Exercise-2-47" class="headerlink" title="Exercise 2.47"></a>Exercise 2.47</h2><pre><code>(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))
(define (origin-frame frame) (car frame))
(define (edge1-frame frame) (cadr frame))
(define (edge2-frame frame) (caddr frame))
</code></pre><p>or</p><pre><code>(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))
(define (origin-frame frame) (car frame))
(define (edge1-frame frame) (cadr frame))
(define (edge2-frame frame) (cddr frame))
</code></pre><h2 id="Exercise-2-48"><a href="#Exercise-2-48" class="headerlink" title="Exercise 2.48"></a>Exercise 2.48</h2><pre><code>(define (make-segment start end) (cons start end))
(define (start-segment segment) (car segment))
(define (end-segment segment) (cdr segment))
</code></pre><h2 id="Exercise-2-49"><a href="#Exercise-2-49" class="headerlink" title="Exercise 2.49"></a>Exercise 2.49</h2><p>a.</p><pre><code>(define outline
  (segments-&gt;painter
   (list (make-segment (make-vect 0.0 0.0) (make-vect 0.0 1.0))
         (make-segment (make-vect 0.0 1.0) (make-vect 1.0 1.0))
         (make-segment (make-vect 1.0 1.0) (make-vect 1.0 0.0))
         (make-segment (make-vect 1.0 0.0) (make-vect 0.0 0.0)))))
</code></pre><p>b.</p><pre><code>(define cross
  (segments-&gt;painter
   (list (make-segment (make-vect 0.0 0.0) (make-vect 1.0 1.0))
         (make-segment (make-vect 0.0 1.0) (make-vect 1.0 0.0)))))
</code></pre><p>c.</p><pre><code>(define diamond
  (segments-&gt;painter
   (list (make-segment (make-vect 0.5 0.0) (make-vect 1.0 0.5))
         (make-segment (make-vect 1.0 0.5) (make-vect 0.5 1.0))
         (make-segment (make-vect 0.5 1.0) (make-vect 0.0 0.5))
         (make-segment (make-vect 0.0 0.5) (make-vect 0.5 0.0)))))
</code></pre><p>d. Too many line segments to draw, I’m skipping this.</p><h2 id="Exercise-2-50"><a href="#Exercise-2-50" class="headerlink" title="Exercise 2.50"></a>Exercise 2.50</h2><pre><code>(define (flip-horiz painter)
  (transform-painter painter
                     (make-vect 0.0 1.0)
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 0.0)))
(define (rotate180 painter)
  (transform-painter painter
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 1.0)
                     (make-vect 1.0 0.0)))
(define (rotate270 painter)
  (transform-painter painter
                     (make-vect 0.0 1.0)
                     (make-vect 0.0 0.0)
                     (make-vect 1.0 1.0)))
</code></pre><h2 id="Exercise-2-51"><a href="#Exercise-2-51" class="headerlink" title="Exercise 2.51"></a>Exercise 2.51</h2><pre><code>(define (below painter1 painter2)
  (let ((split-point (make-vect 0.0 0.5)))
    (let ((paint-bottom
           (transform-painter painter1
                              (make-vect 0.0 0.0)
                              (make-vect 1.0 0.0)
                              split-point))
         (paint-top
           (transform-painter painter2
                              split-point
                              (make-vect 1.0 0.5)
                              (make-vect 0.0 1.0))))
        (lambda (frame)
          (paint-bottom frame)
          (paint-top frame)))))
</code></pre><p>or</p><pre><code>(define (below painter1 painter2)
  (rotate270 (beside (rotate90 painter2)
                     (rotate90 painter1))))
</code></pre><h2 id="Exercise-2-52"><a href="#Exercise-2-52" class="headerlink" title="Exercise 2.52"></a>Exercise 2.52</h2><p>a.</p><pre><code>(define (add-segments segment-list painter)
  (lambda (frame)
    ((segments-&gt;painter segment-list) frame)
    (painter frame)))
(define smiley-wave
  (add-segments (list &lt;smiley segments&gt;) wave))
</code></pre><p>b.</p><pre><code>(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ((up-smaller (up-split painter (- n 1))))
        (below (right-split painter n)
               (beside up-smaller
                       (corner-split painter (- n 1)))))))
</code></pre><p>c. Made Mr. Rogers look outward.</p><pre><code>(define (compose . procs)
  (lambda (x)
    (define (impl procs)
      (if (null? procs)
          x
          ((car procs) (impl (cdr procs)))))
    (impl procs)))
(define (square-limit painter n)
  (define (corner-split-n painter)
    (corner-split painter n))
  ((square-of-four (compose flip-horiz corner-split-n flip-horiz)
                   (compose corner-split-n flip-horiz)
                   (compose flip-horiz flip-vert corner-split-n flip-horiz)
                   (compose flip-vert corner-split-n flip-horiz))
   painter))
</code></pre></div></div></div><div class="card"><div class="card-content"><h3 class="title is-5 has-text-weight-normal">Comments</h3><div id="valine-thread" class="content"></div><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>new Valine({el:"#valine-thread",notify:!1,verify:!1,app_id:"jUDJCYuOij3UzEzFmRpQer5U-gzGzoHsz",app_key:"h2AVOMeF8QsLYFdVVbbf9d7k",placeholder:"Suggestions are welcome.",lang:"en"})</script></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start has-text-centered-mobile has-mb-6-mobile"><p>This work is licensed under a <a rel="license noopener external nofollow noreferrer" title="Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">Creative Commons License</a></p></div><div class="level-end has-text-centered-mobile has-mb-5-mobile"><p class="is-size-7">&copy;&nbsp;2020<span style="padding-left:.06em">–</span>2023&nbsp;duinomaker<span>&nbsp;&nbsp;|&nbsp;&nbsp;</span><i class="fas fa-file-word"></i>&nbsp;57.5k&nbsp;words in total<span>&nbsp;&nbsp;|&nbsp;&nbsp;</span><a class="has-link-black-ter" rel="license noopener external nofollow noreferrer" title="Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank"><i class="fab fa-creative-commons"></i>&nbsp;&nbsp;<i class="fab fa-creative-commons-by"></i>&nbsp;&nbsp;<i class="fab fa-creative-commons-nc"></i>&nbsp;&nbsp;<i class="fab fa-creative-commons-sa"></i></a></p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script>var IcarusThemeSettings={site:{url:"https://duinomaker.top",external_link:{enable:!0,exclude:[]}},article:{highlight:{clipboard:!1,fold:"unfolded"}}}</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js" defer="defer"></script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/auto-render.min.js" defer="defer"></script><script>document.addEventListener("DOMContentLoaded",function(){for(contents=document.getElementsByClassName("has-math"),i=0;i<contents.length;++i)renderMathInElement(contents[i],{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script src="/assets/main.js" defer="defer"></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"> <input type="text" class="searchbox-input ins-search-input" placeholder="Type something..."><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)"},CONTENT_URL:"/assets/content.json"}</script><script src="/assets/insight.js" defer="defer"></script><link rel="stylesheet" href="/assets/search.css"><link rel="stylesheet" href="/assets/insight.css"></body></html>