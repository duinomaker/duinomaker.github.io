<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>初等数论习题</title>
      <link href="/posts/elementary-number-theory-exercises/"/>
      <url>/posts/elementary-number-theory-exercises/</url>
      
        <content type="html"><![CDATA[<p>最近学校在教 “信息安全数学基础” 这门课程, 目前讲到了数论的基础知识. 我选择了 Kenneth H. Rosen 著作的《初等数论及其应用》作为辅助教材, 阅读过程中理解了一些有趣的结论, 证明和习题.</p><span id="more"></span><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>1.&nbsp;<a href="#section-01">“如果 $a,b$ 和 $c$ 为整数, 且 $c\mid ab,$ 则 $c\mid(a,c)(b,c)$”</a><br>2.&nbsp;<a href="#section-02">多元线性同余方程解的个数</a></p><hr><p><span id="section-01"></span></p><h3 id="“如果-a-b-和-c-为整数-且-c-mid-ab-则-c-mid-a-c-b-c-”"><a href="#“如果-a-b-和-c-为整数-且-c-mid-ab-则-c-mid-a-c-b-c-”" class="headerlink" title="“如果 $a,b$ 和 $c$ 为整数, 且 $c\mid ab,$ 则 $c\mid(a,c)(b,c)$”"></a>“如果 $a,b$ 和 $c$ 为整数, 且 $c\mid ab,$ 则 $c\mid(a,c)(b,c)$”</h3><p>对于课后习题中的这个命题, 参考书<span class="serif"><sup>[<a href="#cite-1">1</a>]</sup></span>中所给的证明过程有误, 用到了 “若 $p^\alpha\mid c,p^\beta\mid c,$ 则 $p^{\max(\alpha,\beta)}\mid c$” 这样的错误结论. 接下来我将给出一种正确的证明过程.</p><p><strong>定义.</strong> 设 $p$ 为素数, $n$ 为正整数. 如果 $p^a\mid n$ 但是 $p^{a+1}\nmid n,$ 我们称 $p^a$ <em>恰整除(exactly divides)</em> $n,$ 记为 $p\,\|\,n.$ 由此定义, 还可以给出恰整除的另一种表示法: $p^a$ 恰整除 $n$ 当且仅当 $n=p^aQ,$ 其中 $Q$ 是不能被 $p$ 整除的整数.</p><p><strong>引理 1.</strong> 设 $p$ 为素数, $a,b$ 为整数. 如果 $p^a\,\|\,m,p^b\,\|\,n,$ 则 $p^{a+b}\,\|\,mn.$<br><strong>证明.</strong> 由恰整除的定义知, $m=p^aQ,n=p^bR,$ 其中 $Q,R$ 为不能被 $p$ 整除的整数. 而 $mn=p^{a+b}QR,$ 其中 $p\nmid QR.$ 再次利用恰整除的定义得 $p^{a+b}\,\|\,mn.$ <span class="qed">$\square$</span></p><p><strong>引理 2.</strong> 设 $p$ 为素数, $a,b,m,n$ 为整数. 如果 $p^a\,\|\,m,p^b\,\|\,n,$ 则 $p^{\min(a,b)}\,\|\,(m,n).$<br><strong>证明.</strong> 设 $p_1,p_2,\ldots,p_n$ 是出现在 $m$ 和 $n$ 的素幂因子分解中的素数. 则 $m,n$ 可表示为 $m=p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_r^{\alpha_r}$ 和 $n=p_1^{\beta_1}p_2^{\beta_2}\cdots p_r^{\beta_r}.$ 不失一般性地以素因子 $p_1$ 为例, 由恰整除的定义得 $p_1^{\alpha_1}\,\|\,m$ 和 $p_1^{\beta_1}\,\|\,n.$ 再由 $(m,n)=p_1^{\min(\alpha_1,\beta_1)}p_2^{\min(\alpha_2,\beta_2)}\cdots p_r^{\min(\alpha_r,\beta_r)}$ 观察到 $p_1^{\min(\alpha_1,\beta_1)}\,\|\,(m,n).$ <span class="qed">$\square$</span></p><p><strong>引理 3.</strong> 若 $r,s,t$ 为非负整数, 且 $r\leq s+t,$ 则 $r\leq\min(r,s)+\min(r,t).$<br><strong>证明.</strong> 分为以下四种情况讨论: 1) 若 $r\leq s$ 且 $r\leq t,$ 则有 $r\leq 2r$ 成立. 2) 若 $r\gt s$ 且 $r\leq t,$ 则有 $r\leq s+r$ 成立. 3) 若 $r\leq s$ 且 $r\gt t,$ 则有 $r\leq r+t$ 成立. 4) 若 $r\gt s$ 且 $r\gt t,$ 则有 $r\leq s+t$ 成立. <span class="qed">$\square$</span></p><p>有了以上定义和引理, 我们可以开始证明原命题.</p><p><strong>定理.</strong> 如果 $a,b$ 和 $c$ 为整数, 且 $c\mid ab,$ 则 $c\mid(a,c)(b,c).$<br><strong>证明.</strong> 设 $p^r\,\|\,c,p^s\,\|\,a$ 和 $p^t\,\|\,b.$ 由 $p^r\,\|\,c$ 和 $c\mid ab$ 得 $p^r\mid ab.$ 由 $p^s\,\|\,a,p^t\,\|\,b$ 和引理 1 得 $p^{s+t}\,\|\,ab.$ 故 $r\leq s+t.$ 由引理 2 得 $p^{\min(r,s)}\,\|\,(a,c)$ 和 $p^{\min(r,t)}\,\|\,(b,c).$ 再由引理 1 得 $p^{\min(r,s)+\min(r,t)}\,\|\,(a,c)(b,c).$ 由引理 3 得 $r\leq\min(r,s)+\min(r,t),$ 故 $p^r\mid(a,c)(b,c).$</p><p>通过上述推理, 如果 $c=p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_n^{\alpha_n}$ 是 $c$ 的素幂因子分解, 那么 $p_j^{\alpha_j}\mid(a,c)(b,c),\;j=1,2,\ldots,n.$ 我们想证明 $p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_i^{\alpha_i}\mid(a,c)(b,c)$ 成立. 利用数学归纳法, 当 $i=1$ 时, 有归纳基础 $p_1^{\alpha_1}\mid(a,c)(b,c)$ 成立. 假设对于 $i=k-1,$ 有 $p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_{k-1}^{\alpha_{k-1}}\mid(a,c)(b,c)$ 成立. 已知 $p_k^{\alpha_k}\mid(a,c)(b,c),$ 则由 $(p_k^{\alpha_k},p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_{k-1}^{\alpha_{k-1}})=1,$ 可得出 $p_k^{\alpha_k}\cdot p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_{k-1}^{\alpha_{k-1}}=p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_k^{\alpha_k}\mid(a,c)(b,c),$ 即 $i=k$ 时命题成立. 从而 $i=n$ 时有 $p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_n^{\alpha_n}=c\mid(a,c)(b,c)$ 成立. <span class="qed">$\square$</span></p><hr><p><span id="section-02"></span></p><h3 id="多元线性同余方程解的个数"><a href="#多元线性同余方程解的个数" class="headerlink" title="多元线性同余方程解的个数"></a>多元线性同余方程解的个数</h3><p><strong>定理.</strong> 设 $a,b,c$ 和 $m$ 是整数, $m&gt;0$ 且 $d=(a,b,m).$ 那么二元线性同余方程 $ax+by\equiv c\pmod m$ 在 $d\mid c$ 时恰有 $dm$ 个不同余的解, 其他情形无解.<br><strong>证明.</strong> 若 $ax+by\equiv c\pmod m,$ 那么存在整数 $k,$ 使得 $ax+by-mk=c.$ 因为 $d$ 是 $a,b,m$ 的公因数, 故 $d\mid ax+by-mk,$ 进而 $d\mid c.$ 所以若 $d\nmid c,$ 那么该同余式无解.</p><p>现在假设同余式有解, 即 $d\mid c.$ 令 $a=da^\prime,b=db^\prime,c=dc^\prime,e=de^\prime.$ 那么 $(a^\prime,b^\prime,m^\prime)=1,$ 我们可以将同余式除以 $m^\prime,$ 得到 $a^\prime x+b^\prime y\equiv c^\prime\pmod{m^\prime},$ 或者</p><p>$$a^\prime x\equiv c^\prime-b^\prime y\pmod{m^\prime}.\tag{$*$}$$</p><p>该同余式有解, 当且仅当 $g=(a^\prime,m^\prime)\mid c^\prime-b^\prime y,$ 这相当于同余式 $b^\prime y\equiv c^\prime\pmod g$ 有解. 这必然成立, 因为 $(b^\prime,g)=(b^\prime,a^\prime,m^\prime)=1,$ 表示该同余式恰有一个解, 我们将其记作 $y_0.$ 注意到, 数列 $y_0,y_0+g,y_0+2g,\ldots,y_0+(m^\prime/g-1)g$ 中的元素关于 $g$ 都同余, 但是关于 $m^\prime$ 都不同余, 也就是说这 $m^\prime/g$ 个数中的的每一个都会在 $(*)$ 式中得到模 $m^\prime$ 不同余的 $c^\prime-b^\prime y.$ 而这每个不同余的 $c^\prime-b^\prime y$ 都可以得出 $(*)$ 式的 $g$ 个不同余的解. 所以 $(*)$ 式共有 $(m^\prime/g)g=m^\prime$ 个不同余的解.</p><p>现在假设 $(x_1,y_1)$ 是原同余式的一个解. 类似地, 注意到数列 $x_1,x_1+m^\prime,x_1+2m^\prime,\ldots,x_1+(d-1)m^\prime$ 中的 $d$ 个数关于 $m^\prime$ 都同余, 关于 $m$ 都不同余; 数列 $y_1,y_1+m^\prime,y_1+2m^\prime,\ldots,y_1+(d-1)m^\prime$ 中的 $d$ 个数关于 $m^\prime$ 都同余, 关于 $m$ 都不同余. 所以对于 $(*)$ 式中的每一个解, 都能在原同余式中生成 $d^2$ 个解. 由于 $(*)$ 式共有 $m^\prime$ 个解, 我们得出原同余式共有 $d^2m^\prime=dm$ 个解. <span class="qed">$\square$</span></p><p>如上述各命题的证明过程有误, 或者有表述含糊的地方, 请不吝在评论区指出. 如有更好的证明方法, 欢迎分享.</p><h2 class="serif" style="text-align:center;">参考资料</h2><p id="cite-1" class="serif">[1] Kenneth H. Rosen, <em>Instructor's Solutions Manual for Elementary Number Theory and Its Applications, 6th ed</em>, p. 57, 3.5.40, 2011, <a href="https://epdf.pub/instructors-solutions-manual-for-elementary-number-theory-and-its-applications-6.html" target="_blank">https://epdf.pub/instructors-solutions-manual-for-elementary-number-theory-and-its-applications-6.html</a>.</p>]]></content>
      
      
      <categories>
          
          <category> Mathematics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Number Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Secretary Problem</title>
      <link href="/posts/secretary-problem/"/>
      <url>/posts/secretary-problem/</url>
      
        <content type="html"><![CDATA[<p>“Imagine there are eight roses in your garden; you inspect them one-by-one randomly. Take the first three roses you encounter as sample and go on. Once you encounter a rose more beautiful than any of the first three roses, you pick it up and stop. How likely is it that the one you picked up is the most beautiful one?”</p><span id="more"></span><p>At the first sight of the problem, I thought that I could solve it using the methods learned from the second chapter of <em>Concrete Mathematics</em>, and I did managed to. In this post, I will generalize the problem above into the case of $N$ roses and $K$ worth of sample size, then show you how to derive the probability in a closed form, using combination and summation strategies.</p><hr><p>Let’s say that these roses have “beauty index” from $1$ through $N$, respectively, without duplication, and that $a_n$ is such index of the $n$-th rose you encounter. In this setup, ‘$N$’ is the most beautiful rose; if we will successfully pick up the most beautiful rose, the roses must follow</p><p>$$\overbrace{a_1\;a_2\;\ldots\;a_K}^{\text{$K$ terms}}\;\overbrace{a_{K+1}\;\ldots\;a_j}^{\text{$(j-K)$ terms}}\;N\;\overbrace{a_{j+2}\;\ldots\;a_N}^{\text{$(N-j-1)$ terms}},\quad\text{for $K\leq j\lt N$,}$$</p><p>where you pick up the $(j+1)$-th rose you inspect, which is also the most beautiful rose. In order for this to happen, all terms from $a_{K+1}$ through $a_j$ must be less than $k=\max(a_1,a_2,\ldots,a_K)$; there are $k$ such terms, but $K$ of them are already in $a_1\,a_2\,\ldots\,a_K$. So, at most $(k-K)$ terms are available to settle between ‘$a_K$’ and ‘$N$’, hence $j$ is at most $k$.</p><p>That means, if $k=\max(a_1,a_2,\ldots,a_K)$, the probability that you pick up the right rose is $\sum_{j=K}^k\frac{(N-j-1)!(k-K)^{\underline{j-K}}}{(N-K)!}$. (Note that $n^{\underline k}$ can denote the number of permutations of $k$ elements out of $n$ elements.)</p><p>(This refers to the notation of <em>falling factorial powers</em>, defined by the rule $n^{\underline k}=n(n-1)\cdots(n-k+1)$. More of its properties are described in <em>Concrete Mathematics</em> Chapter 2, partially available in <a href="/CM/notes/2/#2-6-Finite-and-Inifinite-Calculus">my notes</a>.)</p><p>Alright, we will readily be able to evaluate the probability if we know how often $\max(a_1,a_2,\ldots,a_K)$ equals to a specific $k$; let the probability be $Q(k)$. What we do is randomly choosing $K$ roses out of $N$ roses, and the largest of them is $k$. In other words, one of the choices must be the rose $k$, and the rest $(K-1)$ choices are made within $(k-1)$ roses that are less beautiful than the rose $k$. It’s now easy to see that</p><p>$$\begin{aligned}Q(k)&amp;=\frac{\binom{k-1}{K-1}}{\binom NK}\\&amp;=\frac K{N^{\underline K}}(k-1)^{\underline{K-1}},\quad\text{for $k\geq K$.}\end{aligned}$$</p><p>To sum up all what was said above, let $P_{N,K}$ be the ultimate probability we’ve been pursuing. We have</p><p>$$\begin{aligned}P_{N,K}&amp;=\sum_{k=K}^{N-1}Q(k)\sum_{j=K}^k\frac{(N-j-1)!(k-K)^{\underline{j-K}}}{(N-K)!}\\&amp;=\sum_{k=K}^{N-1}\frac K{N^{\underline K}}(k-1)^{\underline{K-1}}\sum_{j=K}^k\frac{(N-j-1)!(k-K)^{\underline{j-K}}}{(N-K)!}\\&amp;=\frac K{N^{\underline K}(N-K)!}\sum_{k=K}^{N-1}\sum_{j=K}^k(N-j-1)!(k-1)^{\underline{K-1}}(k-K)^{\underline{j-K}}\\&amp;=\frac K{N!}\sum_{k=K}^{N-1}\sum_{j=K}^k(N-j-1)!(k-1)^{\underline{K-1}}(k-K)^{\underline{j-K}}\\&amp;=\frac K{N!}\sum_{k=K}^{N-1}\sum_{j=K}^k(N-j-1)!(k-1)^{\underline{j-1}}\\&amp;=\frac K{N!}\sum_{K\leq k\lt N}\sum_{K\leq j\leq k}(N-j-1)!(k-1)^{\underline{j-1}}\\&amp;=\frac K{N!}\sum_{K\leq j\lt N}\sum_{j\leq k\lt N}(N-j-1)!(k-1)^{\underline{j-1}}\\&amp;=\frac K{N!}\sum_{K\leq j\lt N}(N-j-1)!\sum_{j\leq k\lt N}(k-1)^{\underline{j-1}}\\&amp;=\frac K{N!}\sum_{K\leq j\lt N}(N-j-1)!\frac{(N-1)^{\underline j}-(j-1)^{\underline j}}j\\&amp;=\frac K{N!}\sum_{K\leq j\lt N}\frac{(N-j-1)!(N-1)^{\underline j}}j\\&amp;=\frac K{N!}\sum_{K\leq j\lt N}\frac{(N-1)!}j\\&amp;=\frac{K(N-1)!}{N!}(H_{N-1}-H_{K-1})\\&amp;=\frac KN(H_{N-1}-H_{K-1}),\end{aligned}$$</p><p>where $H_k$ is the $k$-th harmonic number, $H_k=1+\frac12+\cdots+\frac1k$.</p><p>Here are some critical observations about the steps above:</p><p>From line 6 to line 7, I interchanged the order of summation, such that $(N-j-1)!$ could be factored out.</p><p>From line 8 to line 9, I used the rule</p><p>$$\sum_{a\leq n\lt b}x^{\underline m}=\frac{b^{\underline{m+1}}-a^{\underline{m+1}}}{m+1},\quad\text{for $m\neq-1$.}$$</p><p>In line 9, $(j-1)^{\underline j}=0$, by the definition of falling factorial powers.</p><p>Back to our initial problem, we have $N=8$ and $K=3$; thus</p><p>$$\begin{aligned}P_{8,3}&amp;=\frac38(H_7-H_2)\\&amp;=\frac38\left(\frac13+\frac14+\frac15+\frac16+\frac17\right)\\&amp;=\frac{459}{1120}.\end{aligned}$$</p><h2 id="Remarks"><a href="#Remarks" class="headerlink" title="Remarks"></a>Remarks</h2><p>So far, I have derived means of evaluating the probability given $N$ and $K$. Further derivations such as methods of optimizing the probability are still under investigation.</p>]]></content>
      
      
      <categories>
          
          <category> Mathematics </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Concrete Mathematics Notes</title>
      <link href="/redirect/concrete-mathematics/"/>
      <url>/redirect/concrete-mathematics/</url>
      
        <content type="html"><![CDATA[<p>I have finished reading the first two chapters of <em>Concrete Mathematics</em>. Here are my notes on the book and solutions to the exercises.</p>]]></content>
      
      
      <categories>
          
          <category> Mathematics </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Miller–Rabin 素性测试</title>
      <link href="/posts/miller-rabin/"/>
      <url>/posts/miller-rabin/</url>
      
        <content type="html"><![CDATA[<p>整理了 Miller–Rabin 素性测试的原理及实现方法.</p><span id="more"></span><hr><p>为了探究一奇数 $n&gt;1$ 是否为素数, 将其用 $e$ 和 $k$ 来表示, 使得 $n-1=2^ek$, 其中 $k$ 为奇数.</p><p>根据 Keith Conrad<span class="serif"><sup>[<a href="#cite-1">1</a>]</sup></span> 的推导, 多项式 $x^{n-1}-1=x^{2^ek}-1$ 可以被分解, 直到指数不是 $2$ 的倍数：</p><p>$$\begin{aligned}x^{n-1}-1&amp;=x^{2^ek}-1\\&amp;=(x^{2^{e-1}k}-1)(x^{2^{e-1}k}+1)\\&amp;=(x^{2^{e-2}k}-1)(x^{2^{e-2}k}+1)(x^{2^{e-1}k}+1)\\&amp;\;\;\vdots\\&amp;=(x^k-1)(x^k+1)(x^{2k}+1)(x^{4k}+1)\cdots(x^{2^{e-1}k}+1).\end{aligned}$$</p><p>若 $n$ 为素数, 且 $1\leq a\leq n-1$, 那么根据费马小定理, 可知 $a^{n-1}-1\equiv0\;({\rm mod}\;n)$, 再根据上式的分解过程, 可以得出</p><p>$$(a^k-1)(a^k+1)(a^{2k}+1)(a^{4k}+1)\cdots(a^{2^{e-1}k}+1)\equiv0\;({\rm mod}\;n).$$</p><p>所以上式中的某一项必须等于 $0\;({\rm mod}\;n)$, 也就是</p><p>$$a^k\equiv1\;({\rm mod}\;n)\;\text{or}\;a^{2^ik}\equiv-1\;({\rm mod}\;n)\;\text{for some}\;i\in\{0,\ldots,n-1\}.$$</p><p>像 Fermat test、Miller–Rabin test 等基于概率的素性测试算法, 目的是找出能够证明 $n$ 是合数的证据. 若找不到这样的证据, 那么 $n$ 很可能是素数. 用这类方法找出的素数称为<em>伪素数(pseudo prime)</em>.</p><p>对于一个奇数 $n&gt;1$, 在 $\{1,\ldots,n-1\}$ 中取一整数 $a$, 如果某个 $a$ 使上式不成立, 也就是</p><p>$$a^k\not\equiv1\;({\rm mod}\;n)\;\text{and}\;a^{2^ik}\not\equiv-1\;({\rm mod}\;n)\;\text{for all}\;i\in\{0,\ldots,n-1\},\quad(*)$$</p><p>那么称这个 $a$ 为一个 Miller–Rabin witness, 在素性测试中, 术语 “witness” 意为某个能够证明 $n$ 为合数的数.</p><p>可以证明<sup class="serif">[<a href="#cite-1">1</a>]</sup>, 若一奇数是合数, 那么 $\{2,\ldots,n-2\}$ 中超过 $75\%$ 的数都是 Miller–Rabin witness. 所以, 若该算法对一个数进行 $k$ 轮检测, 并判定其为素数, 那么该数确实是素数的可能性至少有 $1-4^{-k}$.</p><p>我在 <em>SICP</em> 的 <a href="/SICP/exercises/1-2/#Exercise-1-28">练习 1.28</a> 中用 Scheme 实现了该素性测试, 其中用<em>非平凡平方根(nontrivial square root)</em> 的概念巧妙地找出了 Miller–Rabin witness, 关键点是修改后的 <code>expmod</code> 过程, 在本来执行 <code>square</code> 的地方加入了检测非平凡平方根的过程.</p><p>我也用 C++ 实现了一遍, 当然不再是递归版的, 思考方式变化极大, 不过更加直接地体现了 $(*)$ 式.</p><figure class="highlight c++"><figcaption><span>Miller-Rabin.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">expmod</span><span class="params">(ll base, ll ex, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>, x = base;</span><br><span class="line">    <span class="keyword">while</span> (ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex &amp; <span class="number">1</span>)</span><br><span class="line">            ans = (ans * x) % mod;</span><br><span class="line">        x = (x * x) % mod;</span><br><span class="line">        ex &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">miller_rabin</span><span class="params">(ll n, <span class="type">int</span> rounds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll k = n - <span class="number">1</span>, e = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!(k &amp; <span class="number">1</span>))</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>, ++e;</span><br><span class="line">    <span class="keyword">while</span> (rounds--) &#123;</span><br><span class="line">        ll a = (<span class="built_in">rand</span>() % (n - <span class="number">1</span>)) + <span class="number">1</span>, b = <span class="built_in">expmod</span>(a, k, n);</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">1</span> || b == n - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">bool</span> composite = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; composite &amp;&amp; i &lt; e; ++i)</span><br><span class="line">            <span class="keyword">if</span> ((b = (b * b) % n) == n - <span class="number">1</span>)</span><br><span class="line">                composite = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (composite)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 class="serif" style="text-align:center;">参考资料</h2><p id="cite-1" class="serif">[1] Keith Conrad, “The Miller–Rabin Test,” <a href="https://kconrad.math.uconn.edu/blurbs/ugradnumthy/millerrabin.pdf" target="_blank">https://kconrad.math.uconn.edu/blurbs/ugradnumthy/millerrabin.pdf</a>.</p>]]></content>
      
      
      <categories>
          
          <category> Mathematics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Number Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间最小公倍数</title>
      <link href="/posts/codeforces-gym-100571-c/"/>
      <url>/posts/codeforces-gym-100571-c/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://codeforces.com/gym/100571/problem/C" title="" target="">Codeforces Hello 2015 (Div.2) - LCM Query</a></p><p>求出某个序列所有给定长度的连续子序列的最小公倍数中的最小值。考虑到有大量询问、无需进行修改，故采用 稀疏表 + 离线处理 的方法。</p><span id="more"></span><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>出题人喜欢最小公倍数&hairsp;$({\rm lcm})$，他提供了一个数列 $a_1,a_2,\ldots,a_n$，并给出了一些 $x$，希望你对每个 $x$ 都求出以下式子的值：</p><p>$$\min_{i=1}^{n-x+1}{\rm lcm}(a_i,a_{i+1},\ldots,a_{i+x-1})$$</p><p>简单来说求出这个数列所有长度为 $x$ 的连续子序列的最小公倍数中的最小值<del>（简单来说？</del></p><p>数列 ${a_i}$ 的长度为 $n$，一个 $x$ 就是一次询问，共有 $m$ 次询问，并有以下限制：</p><p>$1\leq n\leq2\times10^4$<br>$1\leq m\leq10^6$<br>$1\leq a_i\leq60$<br>$1\leq x\leq n$</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>对于一个数 $x$，可以将其分解质因数：$x=p_1^{b_1}\times p_2^{b_2}\times\ldots\times p_k^{b_k}$，其中 $p_i$ 指第 $i$ 个素数。于是 $x$ 就可以表示为一个数列 $b$&hairsp;。用这种表示方法，可以很方便地表示最小公倍数。假设有两个数 $x=p_1^{b_1}\times p_2^{b_2}\times\ldots\times p_k^{b_k}$ 和 $y=p_1^{c_1}\times p_2^{c_2}\times\ldots\times p_k^{c_k}$，那么就有：</p><p>$${\rm lcm}(x,y)=p_1^{\max(b_1,c_1)}\times p_2^{\max(b_2,c_2)}\times\ldots\times p_k^{\max(b_k,c_k)}$$</p><p>由于题目要求让结果对 $10^9 + 7$ 取模，算出的结果不能直接比较大小。所以利用对数的性质，取对数后再比较对数的大小：</p><p>$$\begin{aligned}\log(x)&amp;=b_1\log(p_1)+b_2\log(p_2)+\ldots+b_k\log(p_k)\\\log(y)&amp;=c_1\log(p_1)+c_2\log(p_2)+\ldots+c_k\log(p_k)\\\log(x)&amp;\lt\log(y)\implies x\lt y\end{aligned}$$</p><p>最后是查询，对于每一个 $x$ 都重新遍历一遍数列是肯定会 TLE 的，所以要先将每一个区间长度的结果处理出来。大概过程是这样的：创建两个 “指针” $l$ 和 $r$&hairsp;。一开始，$l$ 和 $r$ 都指向第一个元素，之后让 $r$ 不断向后移动，直至指向第一个 ${\rm lcm}$ 值$ {\rm lcm}(a_l,a_{l+1},\ldots,a_r)$ 与之前的 ${\rm lcm}$ 值不同的元素，并用之前的 ${\rm lcm}$ 值更新 $ans_{r-l}$ 的值。再向右移动 $r$ 并如此更新，直至数列尾后元素。之后 $l$ 和 $r$ 同时指向第二个元素，重复上述操作，再同时指向第三个元素…… 直至同时指向数列的尾部元素。</p><p>以数列 $12,3,6,25,5,7$ 举例：</p><ol><li>$l=0,r=3$，用 ${\rm lcm}(12,3,6)=12$ 更新 $ans_3$</li><li>$l=0,r=5$，用 ${\rm lcm}(12,3,6,25,5)=300$ 更新 $ans_5$</li><li>$l=0,r=6$，用 ${\rm lcm}(12,3,6,25,5,7)=2100$ 更新 $ans_6$</li><li>$l=1,r=3$，用 ${\rm lcm}(3,6)=6$ 更新 $ans_2$</li><li>……</li></ol><p>这部分比较难搞懂，代码中已经用 $64$ 道反斜杠划出了重点。</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight c++"><figcaption><span>lcm-query.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e4</span> + <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> lg2maxn = <span class="number">15</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> lg2[maxn], pw2[lg2maxn], ansi[maxn];</span><br><span class="line">vi rmq[maxn][lg2maxn], ans[maxn], p;</span><br><span class="line">vector&lt;<span class="type">double</span>&gt; lnp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i != maxn; ++i)</span><br><span class="line">        lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != lg2maxn; ++i)</span><br><span class="line">        pw2[i] = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">60</span>; ++i) &#123;</span><br><span class="line">        <span class="type">bool</span> prime = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; prime &amp;&amp; j * j &lt;= i; ++j)</span><br><span class="line">            <span class="keyword">if</span> (!(i % j))</span><br><span class="line">                prime = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (prime)</span><br><span class="line">            p.<span class="built_in">push_back</span>(i), lnp.<span class="built_in">push_back</span>(<span class="built_in">log</span>((<span class="type">double</span>)i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fill</span>(ans, ans + maxn, <span class="built_in">vi</span>(p.<span class="built_in">size</span>(), <span class="number">7</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vi <span class="title">lcm</span><span class="params">(<span class="type">const</span> vi&amp; a, <span class="type">const</span> vi&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vi <span class="title">res</span><span class="params">(p.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, i_ = p.<span class="built_in">size</span>(); i != i_; ++i)</span><br><span class="line">        res[i] = <span class="built_in">max</span>(a[i], b[i]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vi <span class="title">intvlcm</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s = lg2[r - l];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lcm</span>(rmq[l][s], rmq[r - pw2[s]][s]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vi <span class="title">itov</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vi <span class="title">res</span><span class="params">(p.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, i_ = p.<span class="built_in">size</span>(); i != i_; ++i)</span><br><span class="line">        <span class="keyword">while</span> (!(x % p[i]))</span><br><span class="line">            ++res[i], x /= p[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vtoi</span><span class="params">(<span class="type">const</span> vi&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, i_ = p.<span class="built_in">size</span>(); i != i_; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = x[i]; j--;)</span><br><span class="line">            res = (res * p[i]) % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vi&amp; a, <span class="type">const</span> vi&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, i_ = p.<span class="built_in">size</span>(); i != i_; ++i)</span><br><span class="line">        x += lnp[i] * a[i], y += lnp[i] * b[i];</span><br><span class="line">    <span class="keyword">return</span> x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t; i != n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t), rmq[i][<span class="number">0</span>] = <span class="built_in">itov</span>(t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lg2[n]; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - pw2[j]; i != <span class="number">-1</span>; --i)</span><br><span class="line">            rmq[i][j] = <span class="built_in">lcm</span>(rmq[i][j - <span class="number">1</span>], rmq[i + pw2[j - <span class="number">1</span>]][j - <span class="number">1</span>]);</span><br><span class="line">    <span class="comment">////////////////////////////////</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l != n; ++l) &#123;</span><br><span class="line">        vi cur = rmq[l][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = l; r != n;) &#123;</span><br><span class="line">            cur = <span class="built_in">lcm</span>(cur, rmq[r][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = lg2[n - r]; k != <span class="number">-1</span>; --k)</span><br><span class="line">                <span class="keyword">if</span> (r + pw2[k] &lt;= n &amp;&amp; <span class="built_in">lcm</span>(cur, rmq[r][k]) == cur)</span><br><span class="line">                    r += pw2[k];</span><br><span class="line">            ans[r - l] = <span class="built_in">min</span>(ans[r - l], cur, cmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">////////////////////////////////</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x; q--;) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ansi[x] ? ansi[x] : (ansi[x] = <span class="built_in">vtoi</span>(ans[x])));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm Contest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Offline Query </tag>
            
            <tag> Sparse Table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稀疏表及其应用</title>
      <link href="/posts/sparse-table/"/>
      <url>/posts/sparse-table/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了稀疏表的基本用法，以及如何在相关习题中应用它。</p><span id="more"></span><p>本文的简介部分主要参照了 <a href="https://oi-wiki.org/" title="" target="">$\text{OI WiKi}$</a> 的<a href="https://oi-wiki.org/ds/sparse-table/" title="ST 表 - OI Wiki" target="">这篇文章</a>。$\text{OI WiKi}$ 整合了各类有关编程竞赛的实用知识，感谢贡献者们！</p><hr><h2 id="为什么使用稀疏表？"><a href="#为什么使用稀疏表？" class="headerlink" title="为什么使用稀疏表？"></a>为什么使用稀疏表？</h2><p>稀疏表是用于解决 “可重复贡献问题” 的数据结构，什么是 “可重复贡献问题”？</p><p>若一个运算 ${\rm op}$ 满足 $x\,{\rm op}\,x=x$，则其对应的区间查询就是 “可重复贡献问题”。例如，最大值有 $\max(x,x)=x$，所以 RMQ 是这类问题；最大公约数有 $\gcd(x,x)=x$，区间最大公约数也是这类问题。区间和就不具备这个性质，如果求区间和所采用的区间有重叠，重叠部分就会被计算两次，这是我们不希望看到的。</p><p>另外，除了 RMQ、区间最大公约数以外，区间按位与、区间按位或等问题，都能够用稀疏表高效解决。这些问题都有着某种相似之处，例如区间按位与，就是每一位都取最小值；区间按位或，就是每一位都取最大值。</p><p>类似的解决这类问题的工具还有线段树。虽然稀疏表不支持修改操作，但是其查询时间被降至常数，在处理有大量询问的问题时十分有效。</p><table><thead><tr><th align="center">&#8203;</th><th align="center">初始化</th><th align="center">区间查询</th><th align="center">单节点修改</th></tr></thead><tbody><tr><td align="center">线段树</td><td align="center">$O(n)$</td><td align="center">$O(\log n)$</td><td align="center">$O(\log n)$</td></tr><tr><td align="center">稀疏表</td><td align="center">$O(n\log n)$</td><td align="center">$O(1)$</td><td align="center">不可</td></tr></tbody></table><h2 id="如何使用稀疏表？"><a href="#如何使用稀疏表？" class="headerlink" title="如何使用稀疏表？"></a>如何使用稀疏表？</h2><p>稀疏表使用 $O(n\log n)$ 的时间，预处理出一张二维的表格 $f(i,j)$&hairsp;。接下来以区间最大值为例，$f(i,j)$ 的含义为 “区间 $[i,i+2^j)$ 上的最大值”。</p><p>假设原数列为 $a$，显然有 $f(i,0)=a_i$&hairsp;。之后使用状态转移方程 $f(i,j)=\max\{f(i,j-1),f(i+2^{j-1},j-1)\}$ 填充完整张表格即可完成预处理。</p><p>若要查询区间 $[l,r)$ 上的最大值，返回 $\max\{f(l,s),f(r-2^s,s)\}$ 即可，其中 $s=\lfloor\log_2(r-l)\rfloor$&hairsp;。</p><h2 id="【习题】"><a href="#【习题】" class="headerlink" title="【习题】"></a>【习题】<a href="https://www.luogu.com.cn/problem/P2880" title="P2880 - [USACO07JAN]Balanced Lineup G" target="">Balanced Lineup</a></h2><p>给出一个序列，每次询问要求回答出某个区间中最大值和最小值之差。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>模板题，需要维护两张稀疏表，一张用于查询区间最大值，另一张用于查询区间最小值。查询后相减得到答案。</p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><figcaption><span>P2880.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">50001</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> lg2maxn = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[maxn][lg2maxn][<span class="number">2</span>], lg2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q, l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;f[i][<span class="number">0</span>][<span class="number">0</span>]), f[i][<span class="number">0</span>][<span class="number">1</span>] = f[i][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lg2[n]; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - (<span class="number">1</span> &lt;&lt; j); i != <span class="number">-1</span>; --i)</span><br><span class="line">            f[i][j][<span class="number">0</span>] = <span class="built_in">min</span>(f[i][j - <span class="number">1</span>][<span class="number">0</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lg2[n]; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - (<span class="number">1</span> &lt;&lt; j); i != <span class="number">-1</span>; --i)</span><br><span class="line">            f[i][j][<span class="number">1</span>] = <span class="built_in">max</span>(f[i][j - <span class="number">1</span>][<span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r), --l;</span><br><span class="line">        <span class="type">int</span> s = lg2[r - l];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">max</span>(f[l][s][<span class="number">1</span>], f[r - (<span class="number">1</span> &lt;&lt; s)][s][<span class="number">1</span>]) - <span class="built_in">min</span>(f[l][s][<span class="number">0</span>], f[r - (<span class="number">1</span> &lt;&lt; s)][s][<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【习题】-1"><a href="#【习题】-1" class="headerlink" title="【习题】"></a>【习题】<a href="https://loj.ac/problem/2279" title="LOJ2279 - 「SCOI2007」降雨量" target="">降雨量</a></h2><p>“$X$ 年是自 $Y$ 年以来降雨量最多的”，它的含义是 $X$ 年的降雨量不超过 $Y$ 年，且对于任意 $Y\lt Z\lt X$，$Z$ 年的降雨量严格小于 $X$ 年。给出两个年份，判断 “$X$ 年是自 $Y$ 年以来降雨量最多的” 这句话是否正确。由于有些年份的降雨量未知，有的说法是可能正确也可以不正确的。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>这题中稀疏表的地位很明确——只是个小工具，用于查询 $X$ 和 $Y$ 年之间的最大降雨量。这题的重头戏在于有些年份的降雨量是未知的，所以回答可能是 “无法判断”。</p><p>代码中的关键点、我曾经忘记考虑的点，都补上了注释，便于查看。</p><h3 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><figcaption><span>LOJ2279.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">50001</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> lg2maxn = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"><span class="type">int</span> key[maxn], val[maxn], f[maxn][lg2maxn], lg2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">intvmax</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= y)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> s = lg2[y - x];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(f[x][s], f[y - (<span class="number">1</span> &lt;&lt; s)][s]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ix = <span class="built_in">lower_bound</span>(key, key + n, x) - key,</span><br><span class="line">        iy = <span class="built_in">lower_bound</span>(key, key + n, y) - key;</span><br><span class="line">    <span class="keyword">if</span> (key[ix] == x) &#123; <span class="comment">// x年的降雨量有记录</span></span><br><span class="line">        <span class="type">int</span> q = <span class="built_in">intvmax</span>(ix + <span class="number">1</span>, iy);</span><br><span class="line">        <span class="keyword">if</span> (key[iy] == y) &#123; <span class="comment">// y年的降雨量有记录</span></span><br><span class="line">            <span class="keyword">if</span> (val[iy] &gt; val[ix])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// y年的降雨量多于x年，则至少得 “自(x-1)年以来……” 才正确</span></span><br><span class="line">            <span class="keyword">if</span> (val[iy] &gt; q) &#123;</span><br><span class="line">                <span class="keyword">if</span> (iy - ix == y - x) <span class="comment">// 之间所有年份的降雨量都已知</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val[ix] &gt; q) <span class="comment">// x年的降雨量至少要比中间多才可能正确</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key[iy] == y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iy &lt;= ix) <span class="comment">// 之间所有年份的降雨量都未知</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> q = <span class="built_in">intvmax</span>(ix, iy);</span><br><span class="line">        <span class="keyword">if</span> (val[iy] &gt; q)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;key[i], &amp;val[i]), f[i][<span class="number">0</span>] = val[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lg2[n]; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - (<span class="number">1</span> &lt;&lt; j); i != <span class="number">-1</span>; --i)</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="type">int</span> flag = <span class="built_in">judge</span>(x, y);</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;maybe&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm Contest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sparse Table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树之懒惰标记</title>
      <link href="/posts/segment-tree-lazytag/"/>
      <url>/posts/segment-tree-lazytag/</url>
      
        <content type="html"><![CDATA[<p>最近在学习线段树的有关知识，期间遇到的重要的知识点和不错的习题，我会总结并记录下来，本系列将持续更新。当前的索引如下：</p><p><span class="mono has-mr-8">[x]-</span><a href="/posts/segment-tree/" title="线段树之基本概念" target="_self">基本概念</a><br><span class="mono has-mr-8">[x]-</span><a href="/posts/segment-tree-lazytag/" title="线段树之懒惰标记" target="_self">懒惰标记</a><br><span class="mono has-mr-8">[ ]-</span>&hellip;&hellip;</p><span id="more"></span><hr><h2 id="为什么引入懒惰标记？"><a href="#为什么引入懒惰标记？" class="headerlink" title="为什么引入懒惰标记？"></a>为什么引入懒惰标记？</h2><p>懒惰标记的用处，就是更快地实现实现区间修改、区间查询。</p><p>考虑之前讲到的线段树。如果用线段树的单点修改，我们需要先改变叶子节点的值，然后不断地向上递归修改祖先节点直至到达根节点，时间复杂度最高可以到达 $O(n\log n)$ 的级别，这还只是单次操作，更别说有 $10^5$ 次指令的情况了。</p><h2 id="该怎么实现？"><a href="#该怎么实现？" class="headerlink" title="该怎么实现？"></a>该怎么实现？</h2><p>其实就是用一个暂时不处理，等到需要用到的时候再进行处理的思想。</p><p>我们想，如果已经到达了属于答案区间范围内的节点，我们就直接对该节点进行一系列的操作，然后直接返回。这样，一定能保证本次区间更新的正确性。然而，区间更新不只一次，如果照刚刚那样更新而不进行任何后处理的话，那么该节点的子节点都未更新，势必会导致答案错误。于是，我们需要一种东西来记录下节点的更新信息，以便下次更新时处理。</p><p>所以引入一个名叫懒惰标记(lazytag) 的东西。之所以称其为 lazytag，是因为当我们引入懒惰标记后，我们不会去更新已经覆盖答案区间的子节点，只有在接下来的操作中我们才可能会用到该区间的子区间。所以这次操作就无需更新。区间更新的期望复杂度就降到了 $O(\log n)$ 的级别。</p><p>之前遇到的，只有单次修改、查询的情况，都是子区间向父区间传递信息，称之为 pushup。而这次将懒惰标记向下传递，不就是反过来，是父区间向子区间传递信息吗？我们将向下传递操作称为 pushdown。</p><p>线段树使用分治法，用递归进行实现。显然，子区间向父区间传递信息，应该在递归地操作子区间之后。而我们为了保证子区间的数据在操作其之前已被更新，就需要在递归操作之前，从父区间向子区间传递消息。</p><p>于是，以区间整体加上一个数的操作为例，就可以如此标记：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  ls[p]   p节点的左端点</span></span><br><span class="line"><span class="comment"> *  rs[p]   p节点的右端点</span></span><br><span class="line"><span class="comment"> *  sum[p]  p节点的区间和</span></span><br><span class="line"><span class="comment"> *  lazy[p] p节点的懒惰标记</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chl (p * 2 + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chr (p * 2 + 2)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 子区间和 += (子区间的元素个数) * 父区间的懒标记</span></span><br><span class="line">    sum[chl] += (rs[chl] - ls[chl]) * lazy[p];</span><br><span class="line">    sum[chr] += (rs[chr] - ls[chr]) * lazy[p];</span><br><span class="line">    <span class="comment">// 父区间的懒标记传递给子区间</span></span><br><span class="line">    lazy[chl] += lazy[p];</span><br><span class="line">    lazy[chr] += lazy[p];</span><br><span class="line">    <span class="comment">// 清零父区间的懒惰标记</span></span><br><span class="line">    lazy[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> val, <span class="type">int</span> p = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= ls[p] &amp;&amp; rs[p] &lt;= y) &#123;</span><br><span class="line">        sum[p] += (rs[p] - ls[p]) * val;</span><br><span class="line">        lazy[p] += val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (ls[p] + rs[p]) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (rs[p] &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">modify</span>(x, y, val, chl);</span><br><span class="line">    <span class="keyword">if</span> (ls[p] &gt;= mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">modify</span>(x, y, val, chr);</span><br><span class="line">    <span class="built_in">modify</span>(x, mid, val, chl);</span><br><span class="line">    <span class="built_in">modify</span>(mid, y, val, chr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我认为懒惰标记的使用，最重要的就是如何 pushdown 了，下面的几道题目很能说明问题。</p><h2 id="【习题】"><a href="#【习题】" class="headerlink" title="【习题】"></a>【习题】<a href="https://www.luogu.com.cn/problem/P3373" title="P3373 - 【模板】线段树 2" target="">线段树 2</a></h2><p>提供一个序列，要求你维护三种操作：</p><ol><li>将某区间每一个数乘上 $x$</li><li>将某区间每一个数加上 $x$</li><li>求出某区间每一个数的和</li></ol><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>在洛谷中作为一道模板题，这道题实在是太虐心了。不过不得不承认，做完以后对线段树和懒惰标记的理解深入了许多。</p><p>看了这题讨论区的题解，很多人说什么先乘后加，我也是想了挺久才弄懂。</p><p>于是考虑这样一个区间 $0$，和它的两个子区间 $1$ 和 $2$，如图：</p><img src="/images/segment-tree-lazytag_1.jpg" width="100%"><p>接着，我们记区间 $i$ 的区间的元素个数为 $span_i$&hairsp;、区间和为 $sum_i$&hairsp;、修改前的初始区间和为 $sum^\prime_i$&hairsp;、区间延迟加法的懒标记为 $lazyadd_i$&hairsp;、区间延迟乘法的懒标记为 $lazymul_i$&hairsp;。于是有以下初始情况，初始情况下，$lazyadd_i=0,lazymul_i=1$：</p><p>$$sum^\prime_0=sum^\prime_0\times\overbrace{1}^{lazymul_0} +\overbrace{0}^{lazyadd_0}\times span_0$$</p><p>考虑将 $0$ 区间，先整体加上 $3$，再整体乘以 $4$，于是有：</p><p>$$\begin{aligned}sum_0=&amp;\,(sum^\prime_0\times\overbrace{1}^{lazymul_0} +\overbrace{0}^{lazyadd_0}\times span_0+3\times span_0)\times4\\=&amp;\,(sum^\prime_0\times\overbrace{1}^{lazymul_0} +\overbrace{3}^{lazyadd_0}\times span_0)\times4\\=&amp;\,sum^\prime_0\times\overbrace{4}^{lazymul_0}+\overbrace{12}^{lazyadd_0}\times span_0\end{aligned}$$</p><p>上式中转换的两步，分别对应了递归更新区间 “懒惰加法” 和 “懒惰乘法” 的代码（<code>rs[p] - ls[p]</code> 即 $span_p$）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加法</span></span><br><span class="line">sum[p] += val * (rs[p] - ls[p]);</span><br><span class="line">lazyadd[p] += val;</span><br><span class="line"><span class="comment">// 乘法</span></span><br><span class="line">sum[p] *= val;</span><br><span class="line">lazyadd[p] *= val;</span><br><span class="line">lazymul[p] *= val;</span><br></pre></td></tr></table></figure><p>接下来考虑父区间将信息传递给子区间的 pushdown 操作。以子区间 $1$ 为例，将父区间加上 $3$ 和乘以 $4$ 的信息传入。假设该区间本身就有懒惰标记，其初始值分别为 $lazyadd^\prime_1$ 和 $lazymul^\prime_1$，于是有：</p><p>$$\begin{aligned}sum_1&amp;=\,(sum^\prime_1\times\overbrace{lazymul^\prime_1}^{lazymul_1}+\overbrace{lazyadd^\prime_1}^{lazyadd_1}\times span_1+3\times span_1)\times4\\&amp;=\,[sum^\prime_1\times\overbrace{lazymul^\prime_1}^{lazymul_1} +\overbrace{(lazyadd^\prime_1+3)}^{lazyadd_1}\times span_1]\times4\\&amp;=\, sum^\prime_1\times\overbrace{lazymul^\prime_1\times4}^{lazymul_1}+\overbrace{(lazyadd^\prime_1\times4+12)}^{lazyadd_1}\times span_1\\&amp;=\, sum^\prime_1\times\overbrace{lazymul^\prime_1\times lazymul_0}^{lazymul_1} +\overbrace{(lazyadd^\prime_1\times lazymul_0+lazyadd_0)}^{lazyadd_1}\times span_1\end{aligned}$$</p><p>上式最后一步的转换比较关键，这样就和父区间建立起了联系。这对应了父区间向下传递的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> chl (p * 2 + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chr (p * 2 + 2)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 更新子区间的区间和与懒惰标记</span></span><br><span class="line">    sum[chl] = sum[chl] * lazymul[p] + lazyadd[p] * (rs[chl] - ls[chl]);</span><br><span class="line">    sum[chr] = sum[chr] * lazymul[p] + lazyadd[p] * (rs[chr] - ls[chr]);</span><br><span class="line">    lazyadd[chl] = lazyadd[chl] * lazymul[p] + lazyadd[p];</span><br><span class="line">    lazyadd[chr] = lazyadd[chr] * lazymul[p] + lazyadd[p];</span><br><span class="line">    lazymul[chl] *= lazymul[p];</span><br><span class="line">    lazymul[chr] *= lazymul[p];</span><br><span class="line">    <span class="comment">// 最后别忘了清零父区间的懒惰标记</span></span><br><span class="line">    lazyadd[p] = <span class="number">0</span>;</span><br><span class="line">    lazymul[p] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这些思路，代码自然就有了。</p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><figcaption><span>P3373.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chl (p * 2 + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chr (p * 2 + 2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> maxn = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> maxt = <span class="number">1</span> &lt;&lt; <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">ll a[maxn], mod;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segtree</span> &#123;</span><br><span class="line">    ll ls[maxt], rs[maxt];</span><br><span class="line">    ll sum[maxt], lazyadd[maxt], lazymul[maxt];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ls[p] = l, rs[p] = r, lazyadd[p] = <span class="number">0</span>, lazymul[p] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            sum[p] = a[l] % mod;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(l, mid, chl);</span><br><span class="line">        <span class="built_in">build</span>(mid, r, chr);</span><br><span class="line">        sum[p] = (sum[chl] + sum[chr]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sum[chl] = (sum[chl] * lazymul[p] + lazyadd[p] * (rs[chl] - ls[chl])) % mod;</span><br><span class="line">        sum[chr] = (sum[chr] * lazymul[p] + lazyadd[p] * (rs[chr] - ls[chr])) % mod;</span><br><span class="line">        lazyadd[chl] = (lazyadd[chl] * lazymul[p] + lazyadd[p]) % mod;</span><br><span class="line">        lazyadd[chr] = (lazyadd[chr] * lazymul[p] + lazyadd[p]) % mod;</span><br><span class="line">        lazymul[chl] = (lazymul[chl] * lazymul[p]) % mod;</span><br><span class="line">        lazymul[chr] = (lazymul[chr] * lazymul[p]) % mod;</span><br><span class="line">        lazyadd[p] = <span class="number">0</span>, lazymul[p] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, ll val, <span class="type">int</span> p = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= ls[p] &amp;&amp; rs[p] &lt;= y) &#123;</span><br><span class="line">            sum[p] = (sum[p] + val * (rs[p] - ls[p])) % mod;</span><br><span class="line">            lazyadd[p] = (lazyadd[p] + val) % mod;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(p);</span><br><span class="line">        <span class="type">int</span> mid = (ls[p] + rs[p]) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; mid)</span><br><span class="line">            <span class="built_in">add</span>(x, y, val, chl);</span><br><span class="line">        <span class="keyword">if</span> (y &gt; mid)</span><br><span class="line">            <span class="built_in">add</span>(x, y, val, chr);</span><br><span class="line">        sum[p] = (sum[chl] + sum[chr]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, ll val, <span class="type">int</span> p = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= ls[p] &amp;&amp; rs[p] &lt;= y) &#123;</span><br><span class="line">            sum[p] = (sum[p] * val) % mod;</span><br><span class="line">            lazyadd[p] = (lazyadd[p] * val) % mod;</span><br><span class="line">            lazymul[p] = (lazymul[p] * val) % mod;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(p);</span><br><span class="line">        <span class="type">int</span> mid = (ls[p] + rs[p]) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; mid)</span><br><span class="line">            <span class="built_in">mul</span>(x, y, val, chl);</span><br><span class="line">        <span class="keyword">if</span> (y &gt; mid)</span><br><span class="line">            <span class="built_in">mul</span>(x, y, val, chr);</span><br><span class="line">        sum[p] = (sum[chl] + sum[chr]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> p = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ls[p] == x &amp;&amp; rs[p] == y)</span><br><span class="line">            <span class="keyword">return</span> sum[p];</span><br><span class="line">        <span class="built_in">pushdown</span>(p);</span><br><span class="line">        <span class="type">int</span> mid = (ls[p] + rs[p]) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (y &lt;= mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(x, y, chl);</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(x, y, chr);</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">query</span>(x, mid, chl) + <span class="built_in">query</span>(mid, y, chr)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; seg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;n, &amp;m, &amp;mod);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    seg.<span class="built_in">build</span>(<span class="number">0</span>, n);</span><br><span class="line">    <span class="type">int</span> op, x, y;</span><br><span class="line">    ll k;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;x, &amp;y), --x;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">3</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, seg.<span class="built_in">query</span>(x, y));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;k);</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">                seg.<span class="built_in">mul</span>(x, y, k);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                seg.<span class="built_in">add</span>(x, y, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【习题】-1"><a href="#【习题】-1" class="headerlink" title="【习题】"></a>【习题】<a href="https://loj.ac/problem/6029" title="LOJ6029 - 「雅礼集训 2017 Day1」市场" target="">市场</a></h2><p>提供一个序列，要求你维护四种操作：</p><ol><li>区间整体加上 $x$</li><li>区间的每一个数除以 $x$，并向下取整</li><li>查询区间最小值</li><li>查询区间和</li></ol><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>这题让我深刻地体会到了，自己是个大常数选手。同一段代码别人用 $2500{\rm ms}$，我的要用 $3300{\rm ms}$&hairsp;。代码常数的差别，不是一两处修改就能赶上来的，有些习惯让大常数的代码无处不在… 说了一些废话。</p><p>这四种操作，我认为第二种是最重要的，其它都只是摆设罢了。</p><p>除以一个数容易想，维护两个懒惰标记，一个对应加法、一个对应除法就行了。可对于整除来说，这方法完全行不通。于是想到，很接近的数，比如 $9$ 和 $10$，在除以 $5$ 并向下取整后将变为 $1$ 和 $2$&hairsp;。相当于给两个数都减去了 $8$&hairsp;。于是，区间整除就变成了区间减法。</p><p>判断整个区间的数是否具备将整除转为区间减法的条件，需要记录下区间的最大值和最小值。一般来说只有最大值等于最小值，也就是区间数字都相同时符合条件。但比如说刚才 $9$ 和 $10$ 的例子，比较大的数能够被除数整除，则最小值可以比最大值小 $1$&hairsp;。</p><h3 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><figcaption><span>LOJ6029.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chl (p * 2 + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chr (p * 2 + 2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxt = <span class="number">1</span> &lt;&lt; <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">floor</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((a &lt; <span class="number">0</span>) ^ (b &lt; <span class="number">0</span>) &amp;&amp; a % b)</span><br><span class="line">        <span class="keyword">return</span> a / b - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segtree</span> &#123;</span><br><span class="line">    <span class="type">int</span> ls[maxt], rs[maxt];</span><br><span class="line">    ll mn[maxt], mx[maxt], sum[maxt], lazy[maxt];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sum[p] = sum[chl] + sum[chr];</span><br><span class="line">        mx[p] = <span class="built_in">max</span>(mx[chl], mx[chr]);</span><br><span class="line">        mn[p] = <span class="built_in">min</span>(mn[chl], mn[chr]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazy[p]) &#123;</span><br><span class="line">            sum[chl] += lazy[p] * (rs[chl] - ls[chl]);</span><br><span class="line">            sum[chr] += lazy[p] * (rs[chr] - ls[chr]);</span><br><span class="line">            mn[chl] += lazy[p];</span><br><span class="line">            mn[chr] += lazy[p];</span><br><span class="line">            mx[chl] += lazy[p];</span><br><span class="line">            mx[chr] += lazy[p];</span><br><span class="line">            lazy[chl] += lazy[p];</span><br><span class="line">            lazy[chr] += lazy[p];</span><br><span class="line">            lazy[p] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ls[p] = l, rs[p] = r, lazy[p] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            sum[p] = mn[p] = mx[p] = a[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(l, mid, chl);</span><br><span class="line">        <span class="built_in">build</span>(mid, r, chr);</span><br><span class="line">        <span class="built_in">pushup</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">intv_add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, ll val, <span class="type">int</span> p = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= ls[p] &amp;&amp; rs[p] &lt;= y) &#123;</span><br><span class="line">            sum[p] += val * (rs[p] - ls[p]);</span><br><span class="line">            lazy[p] += val;</span><br><span class="line">            mn[p] += val;</span><br><span class="line">            mx[p] += val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(p);</span><br><span class="line">        <span class="type">int</span> mid = (ls[p] + rs[p]) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; mid)</span><br><span class="line">            <span class="built_in">intv_add</span>(x, y, val, chl);</span><br><span class="line">        <span class="keyword">if</span> (y &gt; mid)</span><br><span class="line">            <span class="built_in">intv_add</span>(x, y, val, chr);</span><br><span class="line">        <span class="built_in">pushup</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">intv_div</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, ll val, <span class="type">int</span> p = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= ls[p] &amp;&amp; rs[p] &lt;= y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mn[p] == mx[p] || (mx[p] - mn[p] == <span class="number">1</span> &amp;&amp; !(mx[p] % val))) &#123;</span><br><span class="line">                val = <span class="built_in">floor</span>(mn[p], val) - mn[p];</span><br><span class="line">                sum[p] += val * (rs[p] - ls[p]);</span><br><span class="line">                lazy[p] += val;</span><br><span class="line">                mn[p] += val;</span><br><span class="line">                mx[p] += val;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(p);</span><br><span class="line">        <span class="type">int</span> mid = (ls[p] + rs[p]) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; mid)</span><br><span class="line">            <span class="built_in">intv_div</span>(x, y, val, chl);</span><br><span class="line">        <span class="keyword">if</span> (y &gt; mid)</span><br><span class="line">            <span class="built_in">intv_div</span>(x, y, val, chr);</span><br><span class="line">        <span class="built_in">pushup</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">query_min</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> p = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ls[p] == x &amp;&amp; rs[p] == y)</span><br><span class="line">            <span class="keyword">return</span> mn[p];</span><br><span class="line">        <span class="built_in">pushdown</span>(p);</span><br><span class="line">        <span class="type">int</span> mid = (ls[p] + rs[p]) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (y &lt;= mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query_min</span>(x, y, chl);</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query_min</span>(x, y, chr);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">query_min</span>(x, mid, chl), <span class="built_in">query_min</span>(mid, y, chr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">query_sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> p = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ls[p] == x &amp;&amp; rs[p] == y)</span><br><span class="line">            <span class="keyword">return</span> sum[p];</span><br><span class="line">        <span class="built_in">pushdown</span>(p);</span><br><span class="line">        <span class="type">int</span> mid = (ls[p] + rs[p]) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (y &lt;= mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query_sum</span>(x, y, chl);</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query_sum</span>(x, y, chr);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query_sum</span>(x, mid, chl) + <span class="built_in">query_sum</span>(mid, y, chr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; seg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    seg.<span class="built_in">build</span>(<span class="number">0</span>, n);</span><br><span class="line">    <span class="type">int</span> op, x, y;</span><br><span class="line">    ll k;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;x, &amp;y), ++y;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;k);</span><br><span class="line">            seg.<span class="built_in">intv_add</span>(x, y, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;k);</span><br><span class="line">            seg.<span class="built_in">intv_div</span>(x, y, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, seg.<span class="built_in">query_min</span>(x, y));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, seg.<span class="built_in">query_sum</span>(x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm Contest </category>
          
          <category> Segment Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Segment Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“滑动窗口” 的优先队列解法</title>
      <link href="/posts/sliding-window/"/>
      <url>/posts/sliding-window/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2823" title="" target="">POJ2823 - Sliding Window</a></p><p>按顺序输出一个序列中每个固定大小的区间里的最值。这题可以用线段树解决，但不如用单调队列效率高。</p><span id="more"></span><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个长度为 $n\leq10^6$ 的序列。有一个大小为 $k$ 的窗口正从序列的最左边滑向最右边，你只能看到窗口中的 $k$ 个数。每过单位时间，窗口就向右平移一个单位。这里举一个序列为 <code>[1 3 -1 -3 5 3 6 7]</code>，$k=3$ 的例子。</p><table><thead><tr><th align="center">窗口位置</th><th align="right">最小值</th><th align="right">最大值</th></tr></thead><tbody><tr><td align="center"><span class="mono"><strong>[$1$&nbsp;&nbsp;$3$&nbsp;&nbsp;$-1$]</strong>&nbsp;$-3$&nbsp;&nbsp;$5$&nbsp;&nbsp;$3$&nbsp;&nbsp;$6$&nbsp;&nbsp;$7$&nbsp;</span></td><td align="right">$-1$</td><td align="right">$3$</td></tr><tr><td align="center"><span class="mono">&nbsp;$1$&nbsp;<strong>[$3$&nbsp;&nbsp;$-1$&nbsp;&nbsp;$-3$]</strong>&nbsp;$5$&nbsp;&nbsp;$3$&nbsp;&nbsp;$6$&nbsp;&nbsp;$7$&nbsp;</span></td><td align="right">$-3$</td><td align="right">$3$</td></tr><tr><td align="center"><span class="mono">&nbsp;$1$&nbsp;&nbsp;$3$&nbsp;<strong>[$-1$&nbsp;&nbsp;$-3$&nbsp;&nbsp;$5$]</strong>&nbsp;$3$&nbsp;&nbsp;$6$&nbsp;&nbsp;$7$&nbsp;</span></td><td align="right">$-3$</td><td align="right">$5$</td></tr><tr><td align="center"><span class="mono">&nbsp;$1$&nbsp;&nbsp;$3$&nbsp;&nbsp;$-1$&nbsp;<strong>[$-3$&nbsp;&nbsp;$5$&nbsp;&nbsp;$3$]</strong>&nbsp;$6$&nbsp;&nbsp;$7$&nbsp;</span></td><td align="right">$-3$</td><td align="right">$5$</td></tr><tr><td align="center"><span class="mono">&nbsp;$1$&nbsp;&nbsp;$3$&nbsp;&nbsp;$-1$&nbsp;&nbsp;$-3$&nbsp;<strong>[$5$&nbsp;&nbsp;$3$&nbsp;&nbsp;$6$]</strong>&nbsp;$7$&nbsp;</span></td><td align="right">$3$</td><td align="right">$6$</td></tr><tr><td align="center"><span class="mono">&nbsp;$1$&nbsp;&nbsp;$3$&nbsp;&nbsp;$-1$&nbsp;&nbsp;$-3$&nbsp;&nbsp;$5$&nbsp;<strong>[$3$&nbsp;&nbsp;$6$&nbsp;&nbsp;$7$]</strong></span></td><td align="right">$3$</td><td align="right">$7$</td></tr></tbody></table><p>你需要找出每一个位置时，窗口中的最大数和最小数，并按顺序输出。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题，图省事的话，套个线段树的板子就好<del>（没看出来哪里省事了）</del>。建两棵线段树，一棵用于查询区间最小值，另一棵用于查询区间最大值。</p><p>分析一下线段树的效率，建树时间为 $O(n)$，单次查询时间为 $O(\log n)$&hairsp;；又一共有 $2(n-k+1)$ 次查询，所以总体时间复杂度大约为 $O(n\log n)$&hairsp;。这对于所给数据来说很可能会超时，所以考虑使用单调队列来解决。</p><p>单调队列具有队列内所有元素单调递增或者单调递减的性质，所以队列中的最小（最大）值一定出现在队首。</p><p>为了维护单调队列，在插入元素 $a_i$ 时需要进行以下操作（以队首为最大值举例）：</p><ol><li>判断队首元素是否超出窗口范围，若是，将其弹出队列；</li><li>将队尾所有小于 $a_i$ 的元素全部弹出队列；</li><li>将 $a_i$ 从队尾入队。</li></ol><p>解决这道题，先将前 $k$ 个元素按规则入队，之后每插入一个元素前都输出队首，便得到了题目要求的结果。</p><p>需要注意，为了判断队首元素是否在窗口范围内，需要保存元素在序列中的位置（代码中的 $pos$ 数组）。</p><p>最后，记得这个，创建并维护一个单调队列并不一定真的得用标准库的 <code>deque&lt;int&gt;</code>，并且用其 <code>push_back</code> 等方法进行操作<del>（大常数选手飘过）</del>。我试过，大概有一个 $2$ 的常数在它前面，在解决这题时效率甚至不及线段树解法。</p><p>完全可以用一个数组模拟双向队列，用 $l$ 和 $r$ 记录队列在数组中的范围。这样，例如弹出队尾元素的操作，仅仅用 <code>--r</code> 就可以完成了。只要确保数组开得足够大，并且操作过程中 $l$ 不会小于 $0$ 即可。</p><h3 id="参考代码-Monotonic-Queue"><a href="#参考代码-Monotonic-Queue" class="headerlink" title="参考代码 (Monotonic Queue)"></a>参考代码 (Monotonic Queue)</h3><figure class="highlight c++"><figcaption><span>MQ.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000007</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> val[maxn], pos[maxn], a[maxn];</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">greater</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">less</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a &lt; b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">bool</span> (*func)(<span class="type">int</span>, <span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != k; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l != r &amp;&amp; <span class="built_in">func</span>(a[i], val[r - <span class="number">1</span>]))</span><br><span class="line">            --r;</span><br><span class="line">        val[r] = a[i], pos[r++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k; i != n; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, val[l]);</span><br><span class="line">        <span class="keyword">if</span> (l != r &amp;&amp; pos[l] + k &lt;= i)</span><br><span class="line">            ++l;</span><br><span class="line">        <span class="keyword">while</span> (l != r &amp;&amp; <span class="built_in">func</span>(a[i], val[r - <span class="number">1</span>]))</span><br><span class="line">            --r;</span><br><span class="line">        val[r] = a[i], pos[r++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, val[l]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">solve</span>(less);</span><br><span class="line">    <span class="built_in">solve</span>(greater);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考代码-Segment-Tree"><a href="#参考代码-Segment-Tree" class="headerlink" title="参考代码 (Segment Tree)"></a>参考代码 (Segment Tree)</h3><p>线段树版本的代码过于丑陋了，所以把它放在了后面。</p><figure class="highlight c++"><figcaption><span>ST.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chl (p * 2 + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chr (p * 2 + 2)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"><span class="type">int</span> m_max[maxn * <span class="number">4</span>], m_min[maxn * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">        m_max[p] = m_min[p] = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(l, mid, chl);</span><br><span class="line">    <span class="built_in">build</span>(mid, r, chr);</span><br><span class="line">    m_max[p] = std::<span class="built_in">max</span>(m_max[chl], m_max[chr]);</span><br><span class="line">    m_min[p] = std::<span class="built_in">min</span>(m_min[chl], m_min[chr]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_min</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == x &amp;&amp; r == y)</span><br><span class="line">        <span class="keyword">return</span> m_min[p];</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (y &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query_min</span>(x, y, l, mid, chl);</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query_min</span>(x, y, mid, r, chr);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">min</span>(<span class="built_in">query_min</span>(x, mid, l, mid, chl), <span class="built_in">query_min</span>(mid, y, mid, r, chr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == x &amp;&amp; r == y)</span><br><span class="line">        <span class="keyword">return</span> m_max[p];</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (y &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query_max</span>(x, y, l, mid, chl);</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query_max</span>(x, y, mid, r, chr);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">max</span>(<span class="built_in">query_max</span>(x, mid, l, mid, chl), <span class="built_in">query_max</span>(mid, y, mid, r, chr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + k &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">query_min</span>(i, i + k, <span class="number">0</span>, n));</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + k &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">query_max</span>(i, i + k, <span class="number">0</span>, n));</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm Contest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Segment Tree </tag>
            
            <tag> Monotonic Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树之基本概念</title>
      <link href="/posts/segment-tree/"/>
      <url>/posts/segment-tree/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了线段树的基础知识，辅之以相关例题。</p><span id="more"></span><hr><p>基本概念部分，因为是初学，理解没有那么深入，自己总结出来可能质量不高，所以本文的前半部分基本照搬了 <a href="https://www.cnblogs.com/silentEAG/" title="SilentEAG - 博客园" target="">$\text{SilentEAG}$</a> 大佬的 <a href="https://www.cnblogs.com/silentEAG/p/10808978.html" title="【讲●解】超全面的线段树：从入门到入坟" target="">这篇文章</a>（有修改），自己着重写了习题部分。</p><h2 id="什么是线段树？"><a href="#什么是线段树？" class="headerlink" title="什么是线段树？"></a>什么是线段树？</h2><p>首先，你得有树的基本知识。</p><p>然后。</p><blockquote><p>线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树的一个结点。</p><footer><strong>百度百科</strong><cite><a href="https://baike.baidu.com/item/%E7%BA%BF%E6%AE%B5%E6%A0%91/10983506">线段树</a></cite></footer></blockquote><p>很懵？没关系，我们继续。</p><p>其实，线段树(Segment Tree)是一种基于分治思想的二叉树结构，如果你学过树状数组，你会清楚地知道两者的差异性，并且随着学习的深入，你会发现线段树是一种更为通用的数据结构。</p><p>可以说，只要是能满足区间可加性（也就是大区间的信息能由它的两个子区间整理得到）的操作，大都可以用线段树解决。</p><p>最基本的线段树包含以下几个概念：</p><ol><li>线段树每个节点表示一个区间；</li><li>线段树的唯一根节点表示整个区间统计范围，如 $[1,N]$&hairsp;；</li><li>线段树的每个叶节点表示一个长度为 $1$ 的元区间，如 $[x,x]$&hairsp;；</li><li>线段树上的每个节点 $[l,r]$，它的左子节点是 $[l,mid]$，右子节点是 $[mid+1,r]$，其中 $mid=(l+r)/2$ (这是线段树最常见的写法，也会有适用于不同问题的其它写法，不过这用于理解线段树的要义足矣）。</li></ol><img src="/images/segment-tree_1.jpg" width="100%" alt="区间长度为 $2$ 的整数次幂"><p>如图，这就是一棵线段树。我们可以发现，当整个区间统计长度为 $2$ 的整数次幂时，整棵线段树一定是一棵完全二叉树，那我们就可以用堆的编号方法来给线段树来编号啊（其实图中已经编好了）。</p><p>如果根节点编号为 $1$&hairsp;。编号为 $x$ 的节点，它的左儿子编号为 $2x$，右儿子编号为 $2x+1$&hairsp;。</p><p>这样，我们就可以用一个数组来存所有节点的编号了！</p><p>诶等等，那万一整个区间长度不是 $2$ 的整数次幂呢？</p><img src="/images/segment-tree_2.jpg" width="100%" alt="区间长度不为 $2$ 的整数次幂"><p>可以<del>惊讶</del>地发现，我们同样可以使用 “父子二倍标记法”。正确性显然，只不过，正是因为这种情况，所以树的最后一层节点编号在数组中的位置可能不是连续的。</p><p>如果区间长度为 $N$，在最理想的状况下，即 $N$ 是 $2$ 的整数次幂时，$N$ 个叶节点的满二叉树有 $N+N/2+N/4+\ldots+1=2N−1$ 个节点。只要不是这种情况，那就还有一层，所以我们保存线段树节点编号的数组的长度 $T$ 要足够。实际应用时将 $N$ 补至 $2$ 的整数次幂，再乘以 $2$ 即可，实际使用时就是这样：</p><p>$$\begin{aligned}N=10^4\to T=2^{15}\\N=10^5\to T=2^{18}\\N=10^6\to T=2^{21}\end{aligned}$$</p><p>当然，不想麻烦的话，可以直接 $T=4N$，也没有问题。</p><p>于是线段树信息储存如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r; <span class="comment">// 每个区间左右端点</span></span><br><span class="line">    <span class="type">int</span> sum; <span class="comment">// 其它区间数据，这里是区间和的例子</span></span><br><span class="line">&#125; seg[maxn * <span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>当然，线段树的写法多种多样，这是最稳的一种，还有一种是记录左右儿子编号的，据说叫做zkw线段树，我以后遇到了可能会补充。</p><h2 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h2><p>我们需要从根节点 “$1$” 出发，向下递归建树，并把每个节点所代表的区间赋给它。当到达了根节点，便传值，再向上维护信息。</p><p>以维护区间和为例，我们可以这样建树：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node&amp; par = seg[p];</span><br><span class="line">    par.l = l, par.r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123; <span class="comment">// 叶节点赋值</span></span><br><span class="line">        par.val = par.prel = par.prer = par.sum = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(l, mid, p * <span class="number">2</span>); <span class="comment">// 递归建左子树</span></span><br><span class="line">    <span class="built_in">build</span>(mid + <span class="number">1</span>, r, p * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 递归建右子树</span></span><br><span class="line">    par.sum = seg[p * <span class="number">2</span>].sum + seg[p * <span class="number">2</span> + <span class="number">1</span>].sum; <span class="comment">// 向上传递区间和的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h2><p>显然，每次操作，我们都需要从根节点开始遍历，递归找到需要修改的叶子节点，然后修改，然后向上传递信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val, <span class="type">int</span> p = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node&amp; par = seg[p];</span><br><span class="line">    <span class="keyword">if</span> (par.l == par.r) &#123; <span class="comment">// 找到了要修改的位置</span></span><br><span class="line">        par.val = par.prel = par.prer = par.sum = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (par.l + par.r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">        <span class="built_in">modify</span>(x, val, p * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">modify</span>(x, val, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    par.sum = seg[p * <span class="number">2</span>].sum + seg[p * <span class="number">2</span> + <span class="number">1</span>].sum; <span class="comment">// 向上传递区间和的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为整棵树的深度是 $\lceil\log N\rceil$，所以单次修改的时间复杂度为 $O(\log N)$&hairsp;。</p><h2 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h2><p>这里直接给出算法过程，正确性显然。</p><ol><li>若当前节点所表示的区间已经被询问区间所完全覆盖，则立即回溯，并传回该点的信息；</li><li>若当前节点的左儿子所表示的区间已经被询问区间所完全覆盖，就递归访问它的左儿子；</li><li>若当前节点的右儿子所表示的区间已经被询问区间所完全覆盖，就递归访问它的右儿子。</li></ol><p>以返回区间和为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> p = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node&amp; par = seg[p];</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= par.l &amp;&amp; par.r &lt;= y)</span><br><span class="line">        <span class="keyword">return</span> par.sum; <span class="comment">// 对应操作1</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = (par.l + par.r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= y)</span><br><span class="line">        sum += <span class="built_in">query</span>(x, y, p * <span class="number">2</span>); <span class="comment">// 对应操作2</span></span><br><span class="line">    <span class="keyword">if</span> (mid &lt; x)</span><br><span class="line">        sum += <span class="built_in">query</span>(x, y, p * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 对应操作3</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么使用线段树？"><a href="#为什么使用线段树？" class="headerlink" title="为什么使用线段树？"></a>为什么使用线段树？</h2><p>先来对比一下普通数组和线段树，看看它们各种操作的时间复杂度。</p><table><thead><tr><th align="center">&#8203;</th><th align="center">初始化</th><th align="center">区间查询</th><th align="center">单节点修改</th></tr></thead><tbody><tr><td align="center">普通数组</td><td align="center">$O(n)$</td><td align="center">$O(n)$</td><td align="center">$O(1)$</td></tr><tr><td align="center">线段树</td><td align="center">$O(n)$</td><td align="center">$O(\log n)$</td><td align="center">$O(\log n)$</td></tr></tbody></table><p>可见，线段树主要是在区间查询上有速度优势，能够应对更多、范围更大的查询。但是相应地，单节点修改需要耗费很多时间。</p><p>然而，线段树很懒，懒得一个个地处理节点修改的请求。为了应对需要修改多个节点的情况，线段树有它自己的策略——<strong>“懒惰标记”</strong>，接下来会学到。</p><p>不过在这之前，先做几道练习题。</p><h2 id="【习题】"><a href="#【习题】" class="headerlink" title="【习题】"></a>【习题】<a href="https://www.luogu.com.cn/problem/SP1716" title="GSS3 - Can you answer these queries III" target="">Can you answer these queries III</a></h2><p>需要你提供一种数据结构使之能够查询区间最大连续子段和，并且支持单点修改。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先考虑区间的最大子段的这些情况：</p><ol><li>连续最大和的区间只在左儿子所对应的区间上；</li><li>连续最大和的区间只在右儿子所对应的区间上；</li><li>连续最大和的区间横跨左右儿子的区间。</li></ol><p>第 $1$ 和第 $2$ 种情况，答案就是左边部分（右边部分）的最大子段和。<br>第 $3$ 种情况复杂一点，答案等于 左边部分从其右端开始的最大子段和 加上 右边部分从其左端开始的最大子段和。</p><p>当然，为了维护区间从其端点开始的最大子段和，还需维护区间和&hairsp;$(sum)$&hairsp;。如此，一个区间从其左端开始的最大子段和，假设左右儿子的位置分别为 $chl$ 和 $chr$，便可以如此维护：</p><p>$$prel_p =\max\{prel_{chl} , sum_{chl} + prel_{chr}\}$$</p><p>从右端开始的最大子段和同理。</p><p>总的来说，我们要维护这几种区间信息：</p><ol><li>区间的最大连续子段和&hairsp;$(val)$</li><li>区间和&hairsp;$(sum)$</li><li>区间从其左端开始的最大子段和&hairsp;$(prel)$</li><li>区间从其左端开始的最大子段和&hairsp;$(prer)$</li></ol><p>接下来是查询部分，一开始当然是在根节点查询所给的区间。在每个节点处的查询又可以分为三种情况处理：</p><ol><li>所查询的区间刚好是该节点的区间，则直接返回该区间；</li><li>所查询的区间全部在该节点区间的左半部分，则返回该节点左儿子查询该区间的结果；</li><li>所查询的区间全部在该节点区间的右半部分，则返回该节点右儿子查询该区间的结果；</li><li>所查询的区间横跨该节点区间的中间，则将所查询的区间根据该节点区间的中点分为左右两部分，分别让该节点的左儿子和右儿子查询这两个区间，并将查询结果 “合并” 后返回。</li></ol><p>所谓 “合并” 的操作其实就是建树时，子节点向上传播信息的操作，我们可以复用这段代码，也就是下方参考代码中的 <code>pushup</code> 函数。</p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><figcaption><span>can-you-answer-these-queries.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> maxn = <span class="number">50007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    ll prel, prer, val, sum;</span><br><span class="line">&#125; seg[maxn * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">ll a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(node&amp; par, <span class="type">const</span> node&amp; lson, <span class="type">const</span> node&amp; rson)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    par.prel = <span class="built_in">max</span>(lson.prel, lson.sum + rson.prel);</span><br><span class="line">    par.prer = <span class="built_in">max</span>(rson.prer, rson.sum + lson.prer);</span><br><span class="line">    par.val = <span class="built_in">max</span>(<span class="built_in">max</span>(lson.val, rson.val), lson.prer + rson.prel);</span><br><span class="line">    par.sum = lson.sum + rson.sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node&amp; par = seg[p];</span><br><span class="line">    par.l = l, par.r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        par.val = par.prel = par.prer = par.sum = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(l, mid, p * <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">build</span>(mid + <span class="number">1</span>, r, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pushup</span>(par, seg[p * <span class="number">2</span>], seg[p * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val, <span class="type">int</span> p = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node&amp; par = seg[p];</span><br><span class="line">    <span class="keyword">if</span> (par.l == par.r) &#123;</span><br><span class="line">        par.val = par.prel = par.prer = par.sum = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (par.l + par.r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">        <span class="built_in">modify</span>(x, val, p * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">modify</span>(x, val, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pushup</span>(par, seg[p * <span class="number">2</span>], seg[p * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> p = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node&amp; par = seg[p];</span><br><span class="line">    <span class="keyword">if</span> (x == par.l &amp;&amp; y == par.r)</span><br><span class="line">        <span class="keyword">return</span> par;</span><br><span class="line">    <span class="type">int</span> mid = (par.l + par.r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= y)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(x, y, p * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; x)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(x, y, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    node res;</span><br><span class="line">    <span class="built_in">pushup</span>(res, <span class="built_in">query</span>(x, mid, p * <span class="number">2</span>), <span class="built_in">query</span>(mid + <span class="number">1</span>, y, p * <span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q, op, x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q); q--;) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (op)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(x, y).val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">modify</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【习题】-1"><a href="#【习题】-1" class="headerlink" title="【习题】"></a>【习题】<a href="http://poj.org/problem?id=2991" title="POJ2991 - Crane" target="">Crane</a></h2><p>有一台起重机。起重机可以看成由 $N$ 条线段首尾相接而成。第 $i$ 条线段的长度是 $L_i$&hairsp;。<br>最开始，所有的线段都笔直连接，指向上方。</p><p>有 $C$ 条操纵起重机的指令。指令 $i$ 给出两个整数 $S_i$ 和 $A_i$，效果是使线段 $S_i$ 和 $S_{i+1}$ 之间的角度变成 $A_i$ 度。其中角度指的是从线段 $S_i$ 开始沿逆时针方向旋转到 $S_{i+1}$ 所经过的角度。最开始所有的角度都是 $180$ 度。</p><p>按顺序执行这 $C$ 条指令，在每条执行后，输出起重机末端（第 $N$ 条线段的端点）的坐标。假设起重机支点的坐标是 $(0,0)$&hairsp;。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>这是在白书上看到的题目，思维难度比较高。花了两天时间才搞懂，我还是太菜了。思路是运用分治的思想，将整个起重机逐次二分为小区间，用线段树解决。每个节点代表一段连续的线段的集合，并维护这两个值：</p><ol><li>将节点左子节点的向量所指的方向作为竖直向上的正方向后，从该节点左子节点的向量起点指向该节点右子节点的向量终点的向量；</li><li>将节点的左右子节点的向量拼接后，右子节点的向量需要旋转的角度。</li></ol><p>第一个值容易维护，如果节点 $p$ 表示的向量是 $(x_p,y_p)$，角度是 $ang_p$，两个儿子节点分别是 $chl$ 和 $chr$，则有：</p><p>$$\begin{aligned}x_p=x_{chl}+(\cos(ang_p)\times x_{chr}-\sin(ang_p)\times y_{chr})\\y_p=y_{chl}+(\sin(ang_p)\times x_{chr}+\cos(ang_p)\times y_{chr})\end{aligned}$$</p><p>比较难维护的是第二个值，旋转角度。我随手画了个图方便理解。</p><img src="/images/segment-tree_3.jpg" width="100%"><p>这张图是 $N=8$ 时的两种情况，左图是将第 $5$ 节变为 $90$ 度，右图是将 $2$ 节变为 $90$ 度。每个带方向的箭头都是某个节点所对应的向量。其中标记黑点的代表需要更新角度值，标记圆圈的代表需要更新向量值。</p><p>可以发现：</p><ol><li>区间长度为 $1$ 的节点不需要更新角度值和向量值；</li><li>若某个节点所对应的区间包含要改变角度的位置 $(l_p &lt; pos &lt; r_p)$，则需要更新其向量值；</li><li>若某个节点需要更新向量值，且其右子节点没有更新角度值，则需要更新其角度值。</li></ol><p>这样，每次更新便可以在 $O(\log n)$ 时间内完成，而根节点所对应向量的值就是要输出的结果。</p><h3 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><figcaption><span>crane.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chl (p * 2 + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chr (p * 2 + 2)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">double</span> x, y, ang;</span><br><span class="line">&#125; seg[maxn * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> prv[maxn], len[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node&amp; par = seg[p];</span><br><span class="line">    par.l = l, par.r = r, par.x = par.ang = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">        par.y = len[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(l, mid, chl);</span><br><span class="line">    <span class="built_in">build</span>(mid, r, chr);</span><br><span class="line">    <span class="comment">// 默认方向是朝上，只需更新纵坐标</span></span><br><span class="line">    par.y = seg[chl].y + seg[chr].y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> pos, <span class="type">double</span> delta, <span class="type">int</span> p = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node&amp; par = seg[p];</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= par.l || pos &gt;= par.r)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 若要旋转的位置是该节点区间的端点，甚至不在节点区间内，则没有任何影响</span></span><br><span class="line">    <span class="built_in">modify</span>(pos, delta, chl);</span><br><span class="line">    <span class="built_in">modify</span>(pos, delta, chr);</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= (par.l + par.r) / <span class="number">2</span>)</span><br><span class="line">        par.ang += delta; <span class="comment">// 若右子节点没有被更新，需要将其向量旋转</span></span><br><span class="line">    <span class="type">double</span> s = <span class="built_in">sin</span>(par.ang), c = <span class="built_in">cos</span>(par.ang);</span><br><span class="line">    <span class="comment">// 将左右子节点的向量拼接，更新本节点</span></span><br><span class="line">    par.x = seg[chl].x + (c * seg[chr].x - s * seg[chr].y);</span><br><span class="line">    par.y = seg[chl].y + (s * seg[chr].x + c * seg[chr].y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n) != EOF) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt++)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i != m; ++i)</span><br><span class="line">            prv[i] = pi; <span class="comment">// 初始方向为上方</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != m; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;len[i]);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">0</span>, m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> pos, deg; n--;) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;pos, &amp;deg);</span><br><span class="line">            <span class="comment">// 利用prv数组，算出角度的变化值，单位是弧度</span></span><br><span class="line">            <span class="type">double</span> rad = (<span class="type">double</span>)deg / <span class="number">180.0</span> * pi;</span><br><span class="line">            <span class="built_in">modify</span>(pos, rad - prv[pos]);</span><br><span class="line">            prv[pos] = rad;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2f %.2f\n&quot;</span>, seg[<span class="number">0</span>].x, seg[<span class="number">0</span>].y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm Contest </category>
          
          <category> Segment Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Segment Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新增Valine评论系统</title>
      <link href="/posts/valine-comment-system/"/>
      <url>/posts/valine-comment-system/</url>
      
        <content type="html"><![CDATA[<p>给博客添加了评论系统 <a href="https://valine.js.org/" title="" target="">Valine</a>，支持 Markdown 写作和 Gravatar 头像。</p><p>当然，博客本身的内容更重要，可是谁不喜欢折腾呢……</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>牛客练习赛58</title>
      <link href="/posts/nowcoder-practice-58/"/>
      <url>/posts/nowcoder-practice-58/</url>
      
        <content type="html"><![CDATA[<p>解题报告 ( <font color="#0db104">A</font><font color="#0db104">B</font><font color="#0db104">C</font><font color="#0db104">D</font><font color="#0db104">E</font><font color="#7a7a7a">F</font> )</p><p>这两天为了把<a href="https://ac.nowcoder.com/acm/contest/4090/E/" title="牛客练习赛58 - E - 最大GCD" target="">E题</a>搞懂，还接触了一些线段树、离线处理的相关知识。虽然这里没有用到线段树，不过它在解决区间问题时是个重要的数据结构，这几天会相应地更新一些探究线段树的文章。</p><span id="more"></span><p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/4090/" title="牛客练习赛58" target="">牛客练习赛58</a></p><hr><p>这次练习赛 AB 两题都是签到题，不必多说。</p><h1 id="C-矩阵消除游戏"><a href="#C-矩阵消除游戏" class="headerlink" title="C. 矩阵消除游戏"></a>C. 矩阵消除游戏</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>牛妹在玩一个名为矩阵消除的游戏，矩阵的大小是 $m$ 行 $n$ 列，第 $i$ 行第 $j$ 列的单元格的权值为 $a_{i,j}$​ ，牛妹可以进行 $k$ 个回合的游戏，在每个回合，牛妹可以选择一行或者选择一列，然后将这一行或者这一列的所有单元格中的权值变为 $0$，同时牛妹的分数会加上这一行或者这一列中的所有单元格的权值的和。</p><p>求出得分的最大值。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行三个整数 $m,n,k$<br>接下来 $m$ 行每行 $n$ 个整数表示矩阵中各个单元格的权值。</p><p>$1\leq m,n\leq15$<br>$1\leq a_{i,j}\leq10^6$<br>$1\leq k\leq m\times n$</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出一个整数表示牛妹能获得的最大分数。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3 2</span><br><span class="line">101 1 102</span><br><span class="line">1 202 1</span><br><span class="line">100 8 100</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">414</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题尝试了不少策略，都是贪心策略，不过都是错的。还没有想到什么更好的办法，那就暴力搜索吧……</p><p>一共取 $k$ 行 / 列，那么就先试着取 $0$ 行 $k$ 列，再试着取 $1$ 行 $k-1$ 列…… 逐次枚举。</p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><figcaption><span>C.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m, n, k;</span><br><span class="line"><span class="type">int</span> mat[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cols_max</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum[<span class="number">20</span>] &#123;&#125;, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j != m; ++j)</span><br><span class="line">            sum[i] += mat[j][i];</span><br><span class="line">    <span class="built_in">sort</span>(sum, sum + n, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != num; ++i)</span><br><span class="line">        res += sum[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> num = <span class="number">1</span>, <span class="type">int</span> sum = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == k + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> rec[<span class="number">20</span>], rsum = <span class="number">0</span>, tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">        rec[i] = mat[row][i];</span><br><span class="line">        rsum += rec[i];</span><br><span class="line">        mat[row][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((tmp = sum + rsum + <span class="built_in">cols_max</span>(k - num)) &gt; ans)</span><br><span class="line">        ans = tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row + <span class="number">1</span>; i != m; ++i)</span><br><span class="line">        <span class="built_in">dfs</span>(i, num + <span class="number">1</span>, sum + rsum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != n; ++i)</span><br><span class="line">        mat[row][i] = rec[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;m, &amp;n, &amp;k);</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j != n; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;mat[i][j]);</span><br><span class="line">            sum += mat[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= <span class="built_in">min</span>(m, n))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    ans = <span class="built_in">cols_max</span>(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != m; ++i)</span><br><span class="line">        <span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-迷宫"><a href="#D-迷宫" class="headerlink" title="D. 迷宫"></a>D. 迷宫</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个 $m\times n$ 的迷宫，迷宫中每个格子用 $0$ 或 $1$ 表示，$0$ 表示该格子可以通过，$1$ 表示该格子是个障碍物，牛妹站在格子 $(1,1)$，出口在格子 $(m,n)$，牛妹想要走出迷宫，但牛妹只会按以下策略走：</p><p>牛妹当前所在的格子称为当前格子</p><ol><li>如果当前格子右边没有障碍物，牛妹就向右走，否则转到2</li><li>如果当前格子下方没有障碍物，牛妹就向下走，否则转到3</li><li>如果当前格子左边没有障碍物，牛妹就向左走，否则转到4</li><li>如果当前格子上方没有障碍物，牛妹就向上走，否则转到5</li><li>牛妹站在原地不动</li></ol><p>由于牛妹按这样的策略可能会无法走到出口，牛妹的好朋友牛牛决定在牛妹离开格子 $(1,1)$ 前把迷宫中的一些非障碍格子变成障碍，帮助牛妹走出迷宫，但是牛牛比较懒，他想要最小化变成障碍的非障碍格子的数量。</p><h2 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行两个整数 $m,n$ 表示迷宫的大小<br>接下来 $m$ 行每行一个长度为 $n$ 的 $01$ 串表示迷宫的格局</p><p>$1\leq n,m\leq1000$</p><h2 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出一个整数表示牛牛最少需要转换成障碍格子的非障碍格子的数量，如果无法帮助牛妹走出迷宫，输出 <code>-1</code>&hairsp;。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">0000</span><br><span class="line">0110</span><br><span class="line">0110</span><br><span class="line">0000</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>这题给出的五条行走策略，有点吓唬人，实际上可以缩减为这两条：</p><ol><li>若右边没有障碍物，向右走一格，否则转到2</li><li>若下边没有障碍物，向下走一格</li></ol><p>这两条都不符合的话，则无法到达终点。如果在某个位置可以向左走一格，下一步一定又得回到右边，从而左右来回移动，无法到达终点。</p><p>有了这两条，即只能向右或者向下走，这个问题就可以用记忆化搜索，或者动态规划来解决了。使用一个表格&hairsp;$(dp)$来记录结果。其中 $dp[i][j]$ 的含义是 “从 $(1,1)$ 位置走到 $(i,j)$ 位置总共放置的障碍物的最少个数”。那么，$(i,j)$ 取终点位置时，表中的便是这题的结果。</p><p>$$dp[i][j]=\begin{cases}0&amp;,i=1,j=1\\dp[i][j-1]&amp;,i=1,j&gt;1\\dp[i-1][j]&amp;,i&gt;1,j=1\\\min\{dp[i][j-1],dp[i-1][j]+1\}&amp;,(i-1,j+1)\text{处没有障碍物}\\\min\{dp[i][j-1],dp[i-1][j]\}&amp;,\text{否则}\end{cases}$$</p><p>仅当右边和下边都没有障碍物，却坚持要向下走时，需要在右边加一个障碍物。这就是上式第四条的含义。</p><p>我写了两个版本的代码，最终发现，动态规划比记忆化搜索快了近十倍。</p><p>统计数组访问（存 / 取）次数后大概分析了一下，这大概是因为动态规划只需要记忆化搜索一半不到的访问量，加之没有函数递归调用的开销。</p><h3 id="参考代码-Memory-Searching"><a href="#参考代码-Memory-Searching" class="headerlink" title="参考代码 (Memory Searching)"></a>参考代码 (Memory Searching)</h3><figure class="highlight c++"><figcaption><span>D_MS.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> maxn = <span class="number">1007</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line"><span class="type">char</span> mat[maxn][maxn];</span><br><span class="line"><span class="type">int</span> dp[maxn][maxn], vis[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x][y])</span><br><span class="line">        <span class="keyword">return</span> dp[x][y];</span><br><span class="line">    vis[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (y != n - <span class="number">1</span> &amp;&amp; mat[x][y + <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        dp[x][y] = <span class="built_in">min</span>(dp[x][y], <span class="built_in">dfs</span>(x, y + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (x != m - <span class="number">1</span> &amp;&amp; mat[x + <span class="number">1</span>][y] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y != n - <span class="number">1</span> &amp;&amp; mat[x][y + <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            dp[x][y] = <span class="built_in">min</span>(dp[x][y], <span class="built_in">dfs</span>(x + <span class="number">1</span>, y) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[x][y] = <span class="built_in">min</span>(dp[x][y], <span class="built_in">dfs</span>(x + <span class="number">1</span>, y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[m - <span class="number">1</span>][n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != m; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, mat[i]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>) == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考代码-Dynamic-Programming"><a href="#参考代码-Dynamic-Programming" class="headerlink" title="参考代码 (Dynamic Programming)"></a>参考代码 (Dynamic Programming)</h3><figure class="highlight c++"><figcaption><span>D_DP.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> maxn = <span class="number">1007</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line"><span class="type">char</span> mat[maxn][maxn];</span><br><span class="line"><span class="type">int</span> dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, mat[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>, mat[<span class="number">1</span>][<span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mat[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>],</span><br><span class="line">                dp[i - <span class="number">1</span>][j] + (mat[i - <span class="number">1</span>][j + <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[m][n] == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[m][n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-最大GCD"><a href="#E-最大GCD" class="headerlink" title="E. 最大GCD"></a>E. 最大GCD</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出长度为 $n$ 的序列，序列中有 $n$ 个元素 $a_1,a_2,\ldots a_n$​，你需要进行 $q$ 次查询，每次查询形如以下格式：<br>       $l\;r\;x$：你需要选择两个整数 $s,t$ 满足 $l\leq s\leq t\leq r$，使得 $\gcd(a[s],a[s+1],\ldots,a[t−1],a[t],x)$ 最大化。</p><h2 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行两个整数 $n,q$<br>第二行 $n$ 个整数 $a_1,a_2,\ldots a_n$​<br>接下来 $q$ 行每行三个整数表示一个查询</p><p>$1\leq l\leq r\leq n,q,x,a_i​\leq10^5$</p><h2 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述"></a>输出描述</h2><p>对于每个查询输出一个整数表示 $\gcd(a[s],a[s+1],\ldots,a[t−1],a[t],x)$ 的最大值。</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br><span class="line">2 4 3 6</span><br><span class="line">1 3 6</span><br><span class="line">1 4 10</span><br></pre></td></tr></table></figure><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>看到这题，我懵圈了好久。查询时 “使得 $\gcd(a[s],a[s+1],\ldots,a[t−1],a[t],x)$ 最大化” 的这个步骤怎么解决？</p><p>实际上是出题人在吓唬人，由于 $\gcd$ 的特殊性质，选取的数越多只会让结果越小。所以查询的实际步骤是 “在 $\{a[l],a[l+1],\ldots,a[r]\}$ 里取一个数 $a_i$，使得 $\gcd(a_i,x)$ 最大化”。</p><p>首先想到的是最朴素的做法：</p><ol><li>对于每一次查询，都将 $[l,r]$ 区间里的每一个数与 $x$ 求最大公约数，途中记录下最大的一个。</li></ol><p>但是这样做的时间复杂度大致是 $O(nq\log(x))$，最坏情况下能达到 $10^{10}$ 数量级，不可行。</p><p>涉及到最大公因数的问题，如果朴素的算法不能解决，那么从因子的角度去考虑无疑是一个有益的尝试：</p><ol><li>首先将所有数的所有因子预存起来</li><li>对于每一次查询，从大到小枚举 $x$ 的因子，对 $[l,r]$ 区间里的每一个数，判断其是否有这个因子。如果枚举过程中出现了共有的因子，这个因子就是要查询的最大值。</li></ol><p>可以给所有数建一个 <code>vector&lt;int&gt;</code>，存储其所有的因子。因子的大小是有序的，这样对于 $x$ 的每个因子，使用二分查找就能在 $O(\log n)$ 的时间复杂度下判断一个数是否有这个因子。</p><p>这样做的时间复杂度大致是 $O(nq\log(F)),F$ 为某个数的因子个数。由于 $[1,10^5]$ 范围内每个数的因子最多也就 $128$ 个，二分查找因子的速度很快。虽然速度比一开始快了一些，最坏情况下还是达到了 $10^{10}$ 数量级，仍然不可行。</p><p>所以接下来，要引进<strong>离线处理</strong>的方法，什么是离线处理？离线处理即不考虑对查询进行立即答复，而是将问题集中起来，最后统一答复。等到所有问题都聚集起来的时候，我们对其分析，往往可以发现各个查询之间有某些关联，利用这些关联得以更有效地解决问题。</p><p>具体到这一题，我们采用离线处理的方法，将查询全部读入后，按照区间右端点的顺序排序 (为什么是按右端点的顺序排序？往下看)。</p><p>之前，查询每个因子，都要重新枚举一次区间里的每一个数，这样效率明显太低。于是可以创建一个数组 $rec$，其中 $rec_i$ 的值表示因子 $i$ 出现的最右位置。每次查询前，需要将 $rec$ 数组更新到右端点 (具体见下方的 <code>update</code> 函数)。之后，对于 $x$ 的某个因子 $i$，只需判断其出现的最后位置是否在查询的左端点之后，即 $rec_i\geq l$ 是否成立，就可以得知其是否在 $[l,r]$ 区间里出现过。</p><p>所以，按照右端点排序的理由就明确了，这样排序的话，可以确保 $rec$ 数组中存储的最右位置不超过当前查询的右端点。</p><p>这样做，需要更新的次数是所有查询右端点的最大值 (最大是 $n$&hairsp;)，每次查询需要 $F$ 次访问 $rec$ 数组 ($F$ 为某个 $x$ 的因子个数)。所以最坏情况下的时间复杂度是 $O(nF+qF)$，大约是 $10^6$ 数量级，符合要求。</p><h3 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><figcaption><span>E.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, x, idx;</span><br><span class="line">&#125; Q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"><span class="type">int</span> a[maxn], rec[maxn], ans[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; fact[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(rec, <span class="number">-1</span>, <span class="built_in">sizeof</span>(rec));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; maxn; j += i)</span><br><span class="line">            fact[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; val : fact[x])</span><br><span class="line">        rec[val] = pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != q; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;Q[i].l, &amp;Q[i].r, &amp;Q[i].x), Q[i].idx = i;</span><br><span class="line">    <span class="built_in">sort</span>(Q, Q + q, [](<span class="type">const</span> query&amp; a, <span class="type">const</span> query&amp; b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != q; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> l = Q[i].l - <span class="number">1</span>, r = Q[i].r - <span class="number">1</span>, &amp;x = Q[i].x, &amp;idx = Q[i].idx;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt;= r)</span><br><span class="line">            <span class="built_in">update</span>(a[pos], pos), ++pos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = fact[x].<span class="built_in">rbegin</span>(), it_ = fact[x].<span class="built_in">rend</span>(); it != it_; ++it)</span><br><span class="line">            <span class="keyword">if</span> (rec[*it] &gt;= l) &#123;</span><br><span class="line">                ans[idx] = *it;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != q; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F-XOR-TREE"><a href="#F-XOR-TREE" class="headerlink" title="F. XOR TREE"></a>F. XOR TREE</h1>]]></content>
      
      
      <categories>
          
          <category> Algorithm Contest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Offline Query </tag>
            
            <tag> Depth-first Searching </tag>
            
            <tag> Brute Force </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DAG的拓扑顺序与深度优先搜索</title>
      <link href="/posts/topological-order-and-depth-first-searching/"/>
      <url>/posts/topological-order-and-depth-first-searching/</url>
      
        <content type="html"><![CDATA[<p>刷 AtCoder 动态规划专题时，卡在了<a href="https://atcoder.jp/contests/dp/tasks/dp_g/" title="AtCoder Educational DP Contest - G - Longest Path" target="">G题</a>上面，大概是因为不熟悉拓扑顺序。</p><p>所以这篇文章将探讨有向无环图中的拓扑顺序与深度优先搜索算法。</p><span id="more"></span><hr><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote><p>In computer science, a topological sort or topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering. </p><footer><strong>Wikipedia</strong><cite><a href="https://en.wikipedia.org/wiki/Topological_sorting/">Topological sorting</a></cite></footer></blockquote><p>拓扑排序，是将一个有向无环图中所有顶点排成一个线性序列，使得图中任意一条边 $\langle u,v\rangle$ 都满足 $u$ 在线性序列中出现在 $v$ 之前。</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>常见的实现算法有这两种，更常见的是第一种，它更符合直观理解。</p><h2 id="Kahn’s-algorithm"><a href="#Kahn’s-algorithm" class="headerlink" title="Kahn’s algorithm"></a>Kahn’s algorithm</h2><p>简单来说，首先创建一个列表用于存储排序后的顶点。找到一个没有出度的顶点，将其放入列表的最后，切断以该顶点为起点的所有边，再去找没有出度的点，并一直重复这些过程直至所有顶点都已加入列表（如果没有全部加入列表却找不出没有出度的顶点了，这张图一定是有环图）。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight c++"><figcaption><span>Kahn.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt[MAXN]; <span class="comment">// cnt[v] means the number of edges end with v</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; from[MAXN]; <span class="comment">// to[v] stores ends of edges starting from </span></span><br><span class="line"><span class="type">int</span> result[MAXN], idx;</span><br><span class="line"><span class="type">bool</span> vis[MAXN]; <span class="comment">// wether a vertx is already in the result list</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m; <span class="comment">// n for vertices, m for edges</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> u, v; <span class="comment">// an edge from u to v</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        from[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        ++cnt[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (idx != n) &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; !cnt[i]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">                result[idx++] = i;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j : from[i])</span><br><span class="line">                    --cnt[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="comment">// finding no vertex with no predecessor</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Not a DAG (cyclic graph).&quot;</span>), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print vertices out in topological order</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, result[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i != n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, result[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Depth-first-search"><a href="#Depth-first-search" class="headerlink" title="Depth-first search"></a>Depth-first search</h2><p>另一种算法使用了深度优先搜索。随意抽取一个未被造访的点进行深度优先搜索，搜索到 “叶子顶点”（只有入度没有出度的顶点）后将其加入搜索结果。深度优先搜索的过程中如果重复遇到同一个顶点，则该图不是 DAG（有回环）。</p><p>这里的深度优先搜索的目的是探索叶子顶点，探索完成后才会将顶点标上已造访的标记。为了判断是否重复遇到同一个顶点，需要使用另一个 “临时标记”，沿途记录某个顶点是否已被造访，并在一次探索完成后删除。要注意与判断该顶点是否已被造访的 “永久标记” 进行区分。</p><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight c++"><figcaption><span>Depth-first-search.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; from[MAXN]; <span class="comment">// to[v] stores ends of edges starting from v</span></span><br><span class="line"><span class="type">int</span> result[MAXN], idx;</span><br><span class="line"><span class="type">bool</span> perm[MAXN], temp[MAXN]; <span class="comment">// permanent mark and temporary mark</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (temp[u])</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Not a DAG (cyclic graph).&quot;</span>), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    temp[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : from[u])</span><br><span class="line">        <span class="keyword">if</span> (!perm[v])</span><br><span class="line">            <span class="built_in">dfs</span>(v);</span><br><span class="line">    temp[u] = <span class="literal">false</span>;</span><br><span class="line">    perm[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// mind that recursion means deferred operations</span></span><br><span class="line">    <span class="comment">// that&#x27;s why we have to do insertions from back to front</span></span><br><span class="line">    result[--idx] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m; <span class="comment">// n for vertices, m for edges</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    idx = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> u, v; <span class="comment">// an edge from u to v</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        from[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (idx)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (!perm[i])</span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print vertices out in topological order</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, result[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i != n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, result[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>这里就用 AtCoder 动态规划专题的 G 题来举例。</p><p>题目链接：<a href="https://atcoder.jp/contests/dp/tasks/dp_g/" title="AtCoder Educational DP Contest - G - Longest Path" target="">AtCoder Educational DP Contest - G - Longest Path</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一张有向无环图，每条边的长度都是 $1$，求出图中最长路径的长度。</p><p>将前面的深度优先搜索算法改一改，除去 “临时标记”，并且在回溯过程中记下以某顶点为起点的最长路径长度&hairsp;$(dp_i)$&hairsp;。</p><p>为什么这与拓扑序有关？深度优先搜索的顺序其实就是拓扑序，先被访问的顶点不会再被访问。所以沿途记录下的最长路径长度，确定后便不再改变。基于先前的的计算结果，按照一定的顺序和规则不断更新，这也是使用动态规划的理由。</p><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight c++"><figcaption><span>G.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; from[MAXN];</span><br><span class="line"><span class="type">int</span> dp[MAXN];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[u])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : from[u]) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        dp[u] = <span class="built_in">max</span>(dp[u], <span class="number">1</span> + dp[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[u] &gt; ans)</span><br><span class="line">        ans = dp[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        from[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!dp[i])</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm Contest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Graph Theory </tag>
            
            <tag> Depth-first Searching </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020牛客寒假算法基础集训营6</title>
      <link href="/posts/nowcoder-2020-winter-camp-6/"/>
      <url>/posts/nowcoder-2020-winter-camp-6/</url>
      
        <content type="html"><![CDATA[<p>解题报告 ( <font color="#0db104">A</font><font color="#0db104">B</font><font color="#7a7a7a">C</font><font color="#0db104">D</font><font color="#7a7a7a">E</font><font color="#0db104">F</font><font color="#0db104">G</font><font color="#0db104">H</font><font color="#7a7a7a">I</font><font color="#0db104">J</font> )</p><p>2020-02-18 增加<a href="https://ac.nowcoder.com/acm/contest/3007/" title="2020牛客寒假算法基础集训营6 - H - 云" target="">H题</a>题解</p><span id="more"></span><p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/3007/" title="2020牛客寒假算法基础集训营6" target="">2020牛客寒假算法基础集训营6</a></p><hr><h1 id="A-配对"><a href="#A-配对" class="headerlink" title="A. 配对"></a>A. 配对</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>现在有正整数集合 $A$ 和 $B$，每个集合里有 $N$ 个数，你要建立他们间的一一映射<br>将每对配对的数字相加可以得到 $N$ 个和，你要做的就是最大化第 $K$ 大的和<br>$1\leq K\leq N\leq100,000$ 输入的所有数字不超过 $10^8$</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行 $2$ 个数字 $N,K$<br>接下来两行，每行 $N$ 个正整数，分别表示 $A$ 和 $B$ 中的元素</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>一行，表示第 $K$ 大的和的最大值</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2 3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>为了使相加后第 $K$ 大的数最大，应该将 $A$ 序列前 $K$ 大的数，与 $B$ 序列前 $K$ 大的数相配对。</p><p>如此看来，可以只保留 $A$ 序列和 $B$ 序列前 $K$ 大的项，而直接舍弃所有后面的项。此时题目便转化为了：将 $A$ 序列和 $B$ 序列前 $K$ 大的项配对求和，求和后序列的最小值最大是多少？</p><p>为了使最小值尽量大，可以将 $A$ 序列由大到小排序，$B$ 序列由小到大排序，并逐项相加。最后求出序列的最小值，就是答案。</p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><figcaption><span>A.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, l, r) for (int i = l, i##_ = r; i &lt; i##_; ++i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A[MAX_N], B[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;A[i]);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;B[i]);</span><br><span class="line">    <span class="built_in">sort</span>(A, A + n, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="built_in">sort</span>(B, B + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != k; ++i)</span><br><span class="line">        A[i] += B[i + n - k];</span><br><span class="line">    <span class="type">int</span> ans = A[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, k)</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; ans)</span><br><span class="line">            ans = A[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-图"><a href="#B-图" class="headerlink" title="B. 图"></a>B. 图</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>现在有一个 $N$ 个点的有向图，每个点仅有一条出边（有可能出现自环）<br>你需要求出图中最长的简单路径包含点的数量<br>$(1\leq N\leq1,000,000)$</p><h2 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行，一个数字 $N$<br>接下来 $N$ 行，每行一个正整数，第 $i+1$ 行的数字表示第 $i$ 个点出边终点的编号<br>（点从 $1$ 开始标号）</p><h2 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h2><p>一行一个数字，最长的简单路径的长度</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>简单路径即不重复经过同一点的路径，这题考察了深度优先搜索技巧。记录下某一点所指向的点&hairsp;$(to_i)$，该点是否已被访问过&hairsp;$(vis_i)$，以及以该点为起点最多经过多少点&hairsp;$(len_i)$&hairsp;。</p><p>具体实现方法见代码。</p><h3 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><figcaption><span>B.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="type">int</span> len[MAXN], to[MAXN];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (vis[to[x]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (len[to[x]]) &#123;</span><br><span class="line">            len[x] = len[to[x]] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> curr = to[x], cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (curr != x) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                curr = to[curr];</span><br><span class="line">            &#125;</span><br><span class="line">            curr = to[x];</span><br><span class="line">            <span class="keyword">while</span> (curr != x) &#123;</span><br><span class="line">                len[curr] = cnt;</span><br><span class="line">                curr = to[curr];</span><br><span class="line">            &#125;</span><br><span class="line">            len[x] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(to[x]);</span><br><span class="line">        <span class="keyword">if</span> (!len[x])</span><br><span class="line">            len[x] = len[to[x]] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len[x] &gt; ans)</span><br><span class="line">        ans = len[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;to[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-汉诺塔"><a href="#C-汉诺塔" class="headerlink" title="C. 汉诺塔"></a>C. 汉诺塔</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>现在你有 $N$ 块矩形木板，第 $i$ 块木板的尺寸是 $X_i\times Y_i$，你想用这些木板来玩汉诺塔的游戏。<br>我们知道玩汉诺塔游戏需要把若干木板按照上小下大的顺序堆叠在一起，但因为木板是矩形，所以有一个问题：<br>第 $i$ 块木板能放在第 $j$ 块木板上方当且仅当 $X_i &lt; X_j$ 且 $Y_i &lt; Y_j$，于是你很可能没法把所有的木板按照一定的次序叠放起来。<br>你想把这些木板分为尽可能少的组，使得每组内的木板都能按照一定的次序叠放。<br>你需要给出任意一种合理的分组方案。<br>提醒：“任意” 意味着你的答案不必和标准输出完全一致，只要正确即可。</p><h2 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行，一个正整数 $N$<br>接下来 $N$ 行，每行两个正整数表示 $X_i$ 和 $Y_i$<br>对于所有的数据 $1\leq N\leq100,000$ 且 $1\leq X_i,Y_i\leq N$，$X_i$ 互不相等且 $Y_i$ 互不相等</p><h2 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出文件包含两行，第一行一个正整数，表示最少组数<br>第二行 $N$ 个正整数，依次表示你的方案中每块木板分在了哪一组<br>组的编号必须是从 $1$ 开始的连续整数</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 1</span><br><span class="line">2 3</span><br><span class="line">3 2</span><br></pre></td></tr></table></figure><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 1 2</span><br></pre></td></tr></table></figure><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><pre><code>待补充</code></pre><h3 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><figcaption><span>C.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="D-重排列"><a href="#D-重排列" class="headerlink" title="D. 重排列"></a>D. 重排列</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个序列的重排列是指对这个序列中的元素进行若干次（包括 $0$ 次）交换操作后得到的新序列<br>在本题中，序列中可能出现重复的数字，他们被视作不同的元素<br>例如，序列 $1\quad1$ 的重排列有两种<br>现在有两个长度为 $N$ 的非负整数序列 $A$ 和 $B$，问有多少种 $A$ 的重排列满足对于所有的 $1\leq i\leq N$，有 $A_i\leq B_i$<br>由于答案可能很大，你只需要输出答案对 $10^9+7$ 取模的结果</p><h2 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入第一行，包含一个正整数 $N$<br>接下来一行，$N$ 个非负整数表示序列 $A$<br>再接下来一行，$N$ 个非负整数表示序列 $B$<br>$1\leq N\leq100,000$ 且 $0\leq A_i,B_i\leq10^9$</p><h2 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述"></a>输出描述</h2><p>一行一个整数，表示答案</p><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><h3 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 1 2 3</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>首先将 $A$ 序列和 $B$ 序列分别由小到大排序。对于 $B$ 序列的每一项，$A$ 序列中小于这一项的项数可以求出，这项数代表可选的排列方案数。</p><p>还要注意的是，已选择的数不能重复选择，需要从方案数里减去已选数的个数。最后将这些方案数相乘即可得出答案：</p><p>$$Answer =\prod_{i=1}^{N}(A\,\text{序列中不大于}\,B_i\,\text{的项数} - (i-1))$$</p><h3 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><figcaption><span>D.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, l, r) for (int i = l, i##_ = r; i &lt; i##_; ++i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> ll MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">constexpr</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll A[MAXN], B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;A[i]);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;B[i]);</span><br><span class="line">    <span class="built_in">sort</span>(A, A + n);</span><br><span class="line">    <span class="built_in">sort</span>(B, B + n);</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n)</span><br><span class="line">        ans = (ans * (<span class="built_in">upper_bound</span>(A, A + n, B[i]) - A - i)) % MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-立方数"><a href="#E-立方数" class="headerlink" title="E. 立方数"></a>E. 立方数</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>对于给定的正整数 $N$，求最大的正整数 $A$，使得存在正整数 $B$，满足 $A^3B=N$<br>输入包含 $T$ 组数据，$1\leq T\leq10,000$ 且 $1\leq N\leq10^{18}$</p><h2 id="输入描述-4"><a href="#输入描述-4" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行数字 $T$ 表示数据组数<br>接下来一行，$T$ 个正整数 $N$</p><h2 id="输出描述-4"><a href="#输出描述-4" class="headerlink" title="输出描述"></a>输出描述</h2><p>$T$ 行，每行一个数字表示答案</p><h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><h3 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">27 24 7 54</span><br></pre></td></tr></table></figure><h3 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><pre><code>待补充</code></pre><h3 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight cpp"><figcaption><span>E.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="F-十字阵列"><a href="#F-十字阵列" class="headerlink" title="F. 十字阵列"></a>F. 十字阵列</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>小Q 新学会了一种魔法，可以对一个 $N$ 行 $M$ 列 的网格上的敌人造成伤害<br>第 $i$ 次使用魔法可以对网格上的一个十字形区域（即第 $x_i$ 行和第 $y_i$ 列的合并）中的每个格子上的敌人造成 $z_i$ 点伤害<br>现在小Q 一共使用了 $H$ 次魔法，你需要在所有的施法完成之后统计造成伤害的情况，详见输出描述<br>提醒：本题输入规模较大，请使用高效的输入方式<br>$1\leq H\leq500,000$ 且 $1\leq x_i,y_i,z_i,N,M\leq2000$ 且 $1\leq x_i\leq N$ 且 $1\leq y_i\leq M$</p><h2 id="输入描述-5"><a href="#输入描述-5" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行 $3$ 个数字 $N,M,H$<br>接下来 $H$ 行，每行 $3$ 个正整数 $x_i，y_i，z_i$</p><h2 id="输出描述-5"><a href="#输出描述-5" class="headerlink" title="输出描述"></a>输出描述</h2><p>为了避免大量的输出，假设第 $i$ 行第 $j$ 列受到的总伤害是 $w_{ij}$<br>你只需要输出 $\sum{(w_{ij}\times(i+j))}$ 对 $10^9+7$ 取模的结果即可</p><h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h2><h3 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 5 5</span><br><span class="line">1 1 1</span><br><span class="line">2 2 2</span><br><span class="line">3 3 3</span><br><span class="line">4 4 4</span><br><span class="line">5 5 5</span><br></pre></td></tr></table></figure><h3 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">890</span><br></pre></td></tr></table></figure><h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><p>加权求和。每个方块的权值是已知的&hairsp;$(i+j)$，一个点对总伤害的贡献，等于该行和该列所有权值的和，乘以伤害。</p><h3 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><figcaption><span>F.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, l, r) for (ll i = l, i##_ = r; i &lt; i##_; ++i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(ll&amp;a, ll&amp;b, ll&amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    a = b = c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((ch = <span class="built_in">getchar</span>()) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        a = (a &lt;&lt; <span class="number">3</span>) + (a &lt;&lt; <span class="number">1</span>) + (ch &amp; <span class="number">0xf</span>);</span><br><span class="line">    <span class="keyword">while</span> ((ch = <span class="built_in">getchar</span>()) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        b = (b &lt;&lt; <span class="number">3</span>) + (b &lt;&lt; <span class="number">1</span>) + (ch &amp; <span class="number">0xf</span>);</span><br><span class="line">    <span class="keyword">while</span> ((ch = <span class="built_in">getchar</span>()) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        c = (c &lt;&lt; <span class="number">3</span>) + (c &lt;&lt; <span class="number">1</span>) + (ch &amp; <span class="number">0xf</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, m, h, x, y, z;</span><br><span class="line">    <span class="built_in">read</span>(n, m, h);</span><br><span class="line">    ll ans = <span class="number">0</span>, mn = ((m + <span class="number">1</span>) * m + (n + <span class="number">1</span>) * n) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, h) &#123;</span><br><span class="line">        <span class="built_in">read</span>(x, y, z);</span><br><span class="line">        ans = (ans + (mn + x * m + y * n - x - y) * z) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="G-括号序列"><a href="#G-括号序列" class="headerlink" title="G. 括号序列"></a>G. 括号序列</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>合法括号序列的定义是：</p><ol><li>空序列是合法括号序列</li><li>如果 $S$ 是一个合法括号序列,那么 $(S)$ 是合法括号序列</li><li>如果 $A$ 和 $B$ 都是合法括号序列,那么 $AB$ 是一个合法括号序列</li></ol><p>现在给定一个括号序列，求最少删去几个括号能得到一个合法的括号序列<br>输入包含 $T$ 组数据，每组数据中，设括号序列的长度为 $N$<br>$1\leq T,\sum^T{(N)}\leq1,000,000$<br>（由于空串是合法的括号序列，所以答案可以是 $N$）</p><h2 id="输入描述-6"><a href="#输入描述-6" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行一个数字 $T$<br>接下来 $T$ 组数据共 $2T$ 行，每组数据第一行是 $N$<br>第二行则是一个长度为 $N$ 的括号序列</p><h2 id="输出描述-6"><a href="#输出描述-6" class="headerlink" title="输出描述"></a>输出描述</h2><p>$T$ 行 $T$ 个数字，表示输入的括号序列最少删去几个括号能得到一个合法的括号序列</p><h2 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h2><h3 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">6</span><br><span class="line">())(()</span><br><span class="line">9</span><br><span class="line">()(()()))</span><br></pre></td></tr></table></figure><h3 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h2><p>记录未封闭的左括号数量。若没有未封闭括号却又出现了右括号，删去；若读取到末尾仍有未封闭括号，说明之前有相同数量的左括号需要删去。</p><h3 id="参考代码-6"><a href="#参考代码-6" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><figcaption><span>G.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> n, cnt = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d &quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">getchar</span>() == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt)</span><br><span class="line">                    --cnt;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans + cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="H-云"><a href="#H-云" class="headerlink" title="H. 云"></a>H. 云</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>现在天空（可视为二维平面）中有 $N$ 朵 ${\rm A}$ 类云，$M$ 朵 ${\rm B}$ 类云，每朵云的形状都可以用边平行于坐标轴的矩形来描述。<br>一开始，${\rm A}$ 类云在第三象限，${\rm B}$ 类云在第一象限，没有任何云和坐标轴有交点。<br>随着风的吹拂，${\rm A}$ 类云以每秒一个单位的速度向右移动，${\rm B}$ 类云以每秒一个单位的速度向下移动，当一朵 ${\rm A}$ 类云和一朵 ${\rm B}$ 类云在某一个时刻有了至少一个公共点，它们就相遇了。<br>现在请你告诉小R，有多少对 ${\rm A}$ 类云和 ${\rm B}$ 类云能够相遇。<br>$1\leq N,M\leq100,000$ 且 $1\leq|X_i|,|Y_i|,|P_i|,|Q_i|\leq10^9$</p><p>注：</p><ol><li>本题输入规模较大，请注意输入的效率</li><li>输入的云的形状可能为退化的矩形（直线或点）</li></ol><h2 id="输入描述-7"><a href="#输入描述-7" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入第一行，包含两个正整数 $N$ 和 $M$<br>接下来 $N$ 行，每行描述一朵 ${\rm A}$ 类云<br>再接下来 $M$ 行，每行描述一朵 ${\rm B}$ 类云<br>一朵云的位置用一行四个数 $A_i,B_i,C_i,D_i$ 表示，意为这朵云左上角在 $(A_i,B_i)$，右下角在&hairsp;$(C_i,D_i)$</p><h2 id="输出描述-7"><a href="#输出描述-7" class="headerlink" title="输出描述"></a>输出描述</h2><p>一行一个整数，表示答案</p><h2 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h2><h3 id="输入-7"><a href="#输入-7" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br><span class="line">-2 -1 -1 -2</span><br><span class="line">1 2 2 1</span><br></pre></td></tr></table></figure><h3 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h2><p>这题需要换个角度思考：${\rm A}$ 类云向右运动，${\rm B}$ 类云向下运动。只是粗略想想的话，会觉得是个很复杂的运动。</p><p>但如果我们在坐标系中添加这样一条辅助线&hairsp;$(x+y=0)$呢？</p><img src="/images/nowcoder-2020-winter-camp-6_1.jpg" width="100%"><p>如图所示，上述运动便可描述为 “云朵们<strong>面对辅助线，向对面的云靠近</strong>，并同时向右下角移动”。</p><p>我们甚至可以忽略 “并同时向右下角移动”，因为这样并不会影响云彩相遇与否。</p><p>如此一来，若两朵云会相遇，它们一定会在辅助线上扫过一个共同的区域。例如，图中红色线段与黑色线段有重合部分，它们一定会相遇。</p><p>所以可以采用投影的方法，将云彩投影到辅助线上，得到一条线段，其在辅助线上的覆盖范围是 $[a-b,c-d]$&hairsp;。最后清点有重合部分的线段对数，即可得到答案。</p><p>清点前需记录下覆盖范围的端点&hairsp;$(node)$，包括其坐标&hairsp;$(pos)$&hairsp;、左端点还是右端点&hairsp;$(lr)$&hairsp;、${\rm A}$ 类云还是 ${\rm B}$ 类云&hairsp;$(type)$&hairsp;。</p><p>具体实现见参考代码，参考了牛客上某些大神的已通过代码，一开始看得很懵，不过领悟了这投影的方法就很好理解了。</p><h3 id="参考代码-7"><a href="#参考代码-7" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><figcaption><span>H.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">4e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="type">int</span> lr;</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node&amp; rhs) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == rhs.pos)</span><br><span class="line">            <span class="keyword">return</span> lr &gt; rhs.lr;</span><br><span class="line">        <span class="keyword">return</span> pos &lt; rhs.pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a, b, c, d;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> cnt[<span class="number">2</span>] = &#123;&#125;, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">        nodes[k++] = &#123; a - b, <span class="number">1</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        nodes[k++] = &#123; c - d, <span class="number">-1</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">        nodes[k++] = &#123; a - b, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line">        nodes[k++] = &#123; c - d, <span class="number">-1</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(nodes, nodes + k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != k; ++i) &#123;</span><br><span class="line">        cnt[nodes[i].type] += nodes[i].lr;</span><br><span class="line">        <span class="keyword">if</span> (nodes[i].lr == <span class="number">1</span>)</span><br><span class="line">            ans += cnt[nodes[i].type ^ <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="I-导航系统"><a href="#I-导航系统" class="headerlink" title="I. 导航系统"></a>I. 导航系统</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>小Q 所在的国家有 $N$ 个城市，城市间由 $N-1$ 条双向道路连接，任意一对城市都是互通的。<br>每条道路有一个长度，自然，小Q 的导航系统能显示每对城市间的最短距离。<br>但是小Q 对这个系统并不太放心，于是他向你求助：<br>给定每对城市间的最短距离，你要判断距离表是否一定有误。<br>如果这张距离表是自洽的，那么请你按升序依次给出每条道路的长度。<br>对于全部的数据，$1\leq N\leq500$，输入的所有数字都是不超过 $10^9$ 的非负整数。</p><h2 id="输入描述-8"><a href="#输入描述-8" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行一个数字 $N$<br>接下来 $N$ 行，每行 $N$ 个正整数<br>第 $i$ 行第 $j$ 列的数字表示城市 $i$ 和城市 $j$ 间的最短距离<br>保证第 $i$ 行第 $i$ 列的数字为 $0$</p><h2 id="输出描述-8"><a href="#输出描述-8" class="headerlink" title="输出描述"></a>输出描述</h2><p>第一行，一个字符串<br>如果距离表没有问题，输出 <code>Yes</code><br>并在接下来的 $N-1$ 行从小到大给出每条道路的长度<br>否则输出 <code>No</code> 即可</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><h3 id="输入-8"><a href="#输入-8" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">0 1 2</span><br><span class="line">1 0 1</span><br><span class="line">2 1 0</span><br></pre></td></tr></table></figure><h3 id="输出-8"><a href="#输出-8" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><h3 id="输入-9"><a href="#输入-9" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">0 1 1</span><br><span class="line">1 0 1</span><br><span class="line">1 1 0</span><br></pre></td></tr></table></figure><h3 id="输出-9"><a href="#输出-9" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h2><pre><code>待补充</code></pre><h3 id="参考代码-8"><a href="#参考代码-8" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><figcaption><span>I.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="J-签到题"><a href="#J-签到题" class="headerlink" title="J. 签到题"></a>J. 签到题</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有一个边长为正整数的三角形，问能否以其三个顶点为圆心画三个圆，使三个圆两两外切<br>三边长均不超过 $10^8$</p><h2 id="输入描述-9"><a href="#输入描述-9" class="headerlink" title="输入描述"></a>输入描述</h2><p>三个正整数，表示三角形的边长</p><h2 id="输出描述-9"><a href="#输出描述-9" class="headerlink" title="输出描述"></a>输出描述</h2><p>如果三条边不能构成三角形，输出 <code>wtnl</code><br>如果三条边能构成三角形但不能画出符合要求的圆，输出 <code>No</code><br>否则输出一行 <code>Yes</code><br>然后在第二行输出一组方案，按升序给出三个圆的半径，保留两位小数</p><h2 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h2><h3 id="输入-10"><a href="#输入-10" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3 3</span><br></pre></td></tr></table></figure><h3 id="输出-10"><a href="#输出-10" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">1.00 1.00 2.00</span><br></pre></td></tr></table></figure><h2 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h2><p>初中数学？</p><h3 id="参考代码-9"><a href="#参考代码-9" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><figcaption><span>J.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a, b, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="keyword">if</span> (b &gt; c) <span class="built_in">swap</span>(b, c);</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="keyword">if</span> (a + b &lt;= c) <span class="built_in">puts</span>(<span class="string">&quot;wtnl&quot;</span>), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Yes\n%.2f %.2f %.2f\n&quot;</span>, (<span class="type">double</span>)(b + a - c) / <span class="number">2.0</span>,</span><br><span class="line">                                    (<span class="type">double</span>)(a + c - b) / <span class="number">2.0</span>,</span><br><span class="line">                                    (<span class="type">double</span>)(b + c - a) / <span class="number">2.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm Contest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Graph Theory </tag>
            
            <tag> Depth-first Searching </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020牛客寒假算法基础集训营5</title>
      <link href="/posts/nowcoder-2020-winter-camp-5/"/>
      <url>/posts/nowcoder-2020-winter-camp-5/</url>
      
        <content type="html"><![CDATA[<p>解题报告 ( <font color="#0db104">A</font><font color="#0db104">B</font><font color="#7a7a7a">C</font><font color="#0db104">D</font><font color="#0db104">E</font><font color="#7a7a7a">F</font><font color="#7a7a7a">G</font><font color="#0db104">H</font><font color="#0db104">I</font><font color="#0db104">J</font> )</p><span id="more"></span><p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/3006/" title="2020牛客寒假算法基础集训营5" target="">2020牛客寒假算法基础集训营5</a></p><hr><h1 id="A-模板"><a href="#A-模板" class="headerlink" title="A. 模板"></a>A. 模板</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>牛牛，牛可乐和牛能组成了一只队伍参加ACM系列赛事，他们起了一个优雅的队名叫~“牛牛战队”。</p><p>牛牛战队在没有比赛的时候，会把各种板子放在密码柜里，防止弄丢。这一个密码由整个队伍掌管。其中牛牛和牛能有两个密钥，各自有一个仅由大写字母构成的字符串。牛可乐则掌握着解密方法。一天，你用一瓶可乐贿赂牛可乐，得到了解密的办法：</p><p>牛可乐将试图通过以下操作用尽可能少的步骤把一个密钥转换为另一个：</p><ul><li>将其中任意一个字母替换为另一个</li><li>把最后一个字母删除</li><li>在尾部添加一个字母 </li></ul><p>得到的转化步数就是最后的密码。</p><p>一天，你和他们队员一起聚餐，你用可乐把他们灌倒了，从牛牛和牛能口中套出了两个密钥。你要趁他们醒之前拿到模板并复印一份再放回去。你能尽快的算出密码吗？</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入数据共 $3$ 行，第一行包括两个整数 $n,m\,(1\leq n,m\leq10^5)$ 表示两个密钥的长度</p><p>第二行包含一个长度为 $n$ 的字符串 $s_1$ 表示第一个密钥。</p><p>第三行包含一个长度为 $m$ 的字符串 $s_2$ 表示第二个密钥。</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>在一行内输出一个整数，表示密码。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">WXYZ</span><br><span class="line">WXY</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于插入和删除操作只能在字符串末尾进行，这题简单了很多。</p><p>$$\text{转化步数}=\max\{m,n\}\,-\,\text{重合的字符个数}$$</p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><figcaption><span>A.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, l, r) for (int i = l, i##_ = r; i &lt; i##_; ++i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, ans = <span class="number">0</span>;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="built_in">min</span>(a.<span class="built_in">length</span>(), b.<span class="built_in">length</span>()))</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[i])</span><br><span class="line">            ++ans;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(m, n) - ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-牛牛战队的比赛地"><a href="#B-牛牛战队的比赛地" class="headerlink" title="B. 牛牛战队的比赛地"></a>B. 牛牛战队的比赛地</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>由于牛牛战队经常要外出比赛，因此在全国各地建立了很多训练基地，每一个基地都有一个坐标 $(x,y)$&hairsp;。<br>这周末，牛牛队又要出去比赛了，各个比赛的赛点都在 $x$ 轴上。牛牛战队为了方便比赛，想找一个到达训练基地最大距离最小的地方作为比赛地。<br>这个问题对于牛牛战队太简单了，它就交给了你，你来帮他算一下~</p><h2 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入数据第一行包含一个整数 $N\, (1\leq N\leq100,000)$，表示牛牛战队训练基地的数量。</p><p>接下来 $N$ 行，每行包括 $2$ 个整数 $x,y\, (-10,000\leq x,y\leq10,000)$，表示每一个训练基地的坐标。</p><h2 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出一个小数，表示选择的比赛地距离各训练基地最大距离的最小值。</p><p>如果你的答案是 $a$，标准答案是 $b$，当 $|a-b|\leq10^{-4}$ 时，你的答案将被判定为正确。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">0 0</span><br><span class="line">2 0</span><br><span class="line">0 2</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>当在 $(0,0)$ 比赛时，到三个训练基地的最大距离是 $2$&hairsp;。可以证明这是最小值。</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>这道题需要对半径使用二分法，判断一个半径是否合法，合法则缩小半径，不合法则扩大半径。</p><p>如何判断一个半径是否合法（即 “这个半径的圆是否有可能囊括所有点”）呢？</p><p>若一个半径合法，一定存在一个区间（或一点），使以区间上任一点为圆心的圆，都能囊括所有的点。我们只需记录下这个区间的左端点和右端点即可。判断时需遍历所有点，遍历时使用 $(x[i]-k,x[i]+k)$ 与原区间的交集更新区间（如图）。</p><iframe src="https://www.desmos.com/calculator/obemfwgcrp?embed" width="100%" height="150" frameborder="0" loading="lazy" allowfullscreen></iframe><p>若最终区间存在，则半径合法，否则不合法。</p><h3 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><figcaption><span>B.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> xs[MAX_N], ys[MAX_N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> rad)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> l = <span class="number">-10010.0</span>, r = <span class="number">10010.0</span>, rsqr = rad * rad;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(ys[i]) &gt; rad)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">double</span> k = <span class="built_in">sqrt</span>(rsqr - ys[i] * ys[i]);</span><br><span class="line">        <span class="keyword">if</span> ((l = <span class="built_in">max</span>(l, xs[i] - k)) &gt; (r = <span class="built_in">min</span>(r, xs[i] + k)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;xs[i], &amp;ys[i]);</span><br><span class="line">    <span class="type">double</span> l = <span class="number">0</span>, r = <span class="number">10010.0</span>, m;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">1e-9</span>) &#123;</span><br><span class="line">        m = (l + r) / <span class="number">2.0</span>;</span><br><span class="line">        (<span class="built_in">check</span>(m) ? r : l) = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.9f\n&quot;</span>, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-C语言IDE"><a href="#C-C语言IDE" class="headerlink" title="C. C语言IDE"></a>C. C语言IDE</h1><h1 id="D-牛牛与牛妹的约会"><a href="#D-牛牛与牛妹的约会" class="headerlink" title="D. 牛牛与牛妹的约会"></a>D. 牛牛与牛妹的约会</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>牛牛在辛苦的一天的比赛之后，要去找牛妹玩，其实牛妹那天也在比赛。他为了找到牛妹，要尽快的从自己的比赛地到她的比赛地。</p><p>还记得吗，比赛地都是只在 $x$ 轴上的，所以两个人的坐标都满足 $y=0$&hairsp;。牛牛除了可以以 $1$ 单位距离/单位时间的速度移动任意时间以外，还可以花费 $1$ 单位时间进行闪现。每次闪现时，如果当前他的坐标是 $x=k$，他将闪现到 $x=\sqrt[3]{k}$ 的位置。</p><p>请帮他算算，最短需要多少时间，他可以找到牛妹~</p><h2 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入数据包括多组用例，输入第一行包含一个数字 $T\,(1\leq T\leq5\times10^5)$，表示数据组数。</p><p>接下来 $T$ 行，每行包括两个整数 $a,b\,(|a|,|b|\leq10^6)$，表示牛牛所在的位置和牛妹所在的位置。</p><h2 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出共 $T$ 行，每行包括一个实数，表示牛牛所花费的最短时间。</p><p>如果你的答案是 $a$，标准答案是 $b$，当 $|a-b|\leq10^{-6}$ 时，你的答案将被判定为正确。</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 -1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.442249570</span><br><span class="line">1.000000000</span><br></pre></td></tr></table></figure><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>为了使时间尽量短，一定是闪现在前，移动在后。不停闪现，直到闪现能够缩短的距离小于 $1$，之后用移动来补全剩下的距离。</p><h3 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><figcaption><span>D.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T, _a, _b;</span><br><span class="line">    <span class="type">double</span> ans, a, b, t;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        cin &gt;&gt; _a &gt;&gt; _b;</span><br><span class="line">        a = _a, b = _b;</span><br><span class="line">        ans = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            t = <span class="built_in">cbrt</span>(a);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1.0</span> + <span class="built_in">abs</span>(t - b) &lt; <span class="built_in">abs</span>(a - b)) &#123;</span><br><span class="line">                ans += <span class="number">1.0</span>;</span><br><span class="line">                a = t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += <span class="built_in">abs</span>(a - b);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.9f\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-Enjoy-the-game"><a href="#E-Enjoy-the-game" class="headerlink" title="E. Enjoy the game"></a>E. Enjoy the game</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>牛牛战队的三个队员在训练之余会自己口胡了一些题当做平时的益智游戏。有一天牛可乐想出了一个小游戏给另外两名队员玩，游戏规则如下：</p><ul><li>初始一共有 $n$ 张卡牌</li><li>先手第一步最少要拿 $1$ 张牌，最多要拿 $n−1$ 张牌。</li><li>接下来每一步，双方最少要拿 $1$ 张牌，最多拿等同于上一步对方拿的牌数的牌。</li><li>拿走最后一张牌的人将取得游戏的胜利。 </li></ul><p>你作为旁观者，看着他们玩得很开心，想参与到这场游戏中来，赌一赌谁会能赢。</p><h2 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入数据包含一个整数 $n\,(2\leq n\leq10^{18})$，表示初始卡牌张数。</p><h2 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述"></a>输出描述</h2><p>如果先手有必胜策略，输出 <code>Bob</code>，否则输出 <code>Alice</code>&hairsp;。</p><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><h3 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alice</span><br></pre></td></tr></table></figure><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><p>先手必须拿走一张牌，然后后手拿走了另一张牌，游戏结束。</p><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>这题是我比较喜欢的一题，考察了你的思维方式。拿到这题的第一想法是在纸上模拟一下，找找规律，模拟的过程中，我发现：</p><p>若纸牌张数为奇数，是一定有必胜策略的，只要一开始只拿一张牌，两人轮流拿牌后一定是自己拿到最后一张牌。</p><p>若纸牌张数为偶数，那么为了不输，拿牌的一方一定是拿偶数张牌的，否则接下来对方会只拿一张牌，并在轮流拿牌后拿到最后一张牌。既然双方为了不输都会拿偶数张牌，我们就可以将牌两两合并，将相邻的两张牌看作一张，从而将问题转化为只有半数牌的情况。</p><p>找到了如上规律，我们就可以解决这个问题了。以 $12$ 张牌的情况举例，我们可以将其等同为 $6$ 张牌的情况，进而等同为 $3$ 张牌的情况。$3$ 为非 $1$ 的奇数，所以是有必胜策略的。事实上，只有当牌数为 $ 2^n (n\in\mathbf{N}^{*})$ 时，是没有必胜策略的。</p><h3 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight cpp"><figcaption><span>E.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">puts</span>((n &amp; (-n)) == n ? <span class="string">&quot;Alice&quot;</span> : <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="未完待续……"><a href="#未完待续……" class="headerlink" title="未完待续……"></a>未完待续……</h1><!--# F. 碎碎念# G. 街机争霸# H. Hash# I. I题是个签到题# J. 牛牛战队的秀场 -->]]></content>
      
      
      <categories>
          
          <category> Algorithm Contest </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>“十字翻转棋问题” 的解法</title>
      <link href="/posts/the-cross-flip-game/"/>
      <url>/posts/the-cross-flip-game/</url>
      
        <content type="html"><![CDATA[<p>十字翻转棋问题有更巧妙的解法吗？线性代数带给我们不少启发。</p><span id="more"></span><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>“传火” 这个游戏，需要点燃 $16$ 个火堆。<br>每个火堆可以处于以下两种状态之一：点燃或熄灭。<br>这 $16$ 个火堆可以表示为一个 $4\times4$ 的方阵，可以对任何一个位置上的火堆进行 “切换”。<br>例如，对 $[i,j]$ 位置的火堆进行切换，会使得第 $i$ 行和第 $j$ 列上的所有火堆的状态也随着改变。<br>要求最终所有的火堆都被点亮。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入一共包含 $4$ 行，每行包含 $4$ 个火堆的初始状态。<br>符号 “<code>+</code>” 表示火堆处于熄灭状态，而符号 “<code>-</code>” 表示火堆处于燃烧状态。<br>输入数据保证至少一个火堆的初始状态是熄灭的。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>第一行输出一个整数 $N$，表示所需的最少切换次数。<br>接下来 $N$ 行描述切换顺序，每行输入两个整数，代表被切换状态的火堆的行号和列号，数字之间用空格隔开。<br>切换动作按照整体从上到下、同行从左到右的顺序输出。</p><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p>输入样例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+++-</span><br><span class="line">+--+</span><br><span class="line">+--+</span><br><span class="line">-+++</span><br></pre></td></tr></table></figure><p>输出样例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure><h2 id="思路与题解"><a href="#思路与题解" class="headerlink" title="思路与题解"></a>思路与题解</h2><p>最直接的思路当然是递归枚举所有可能的切换方式了。先枚举只切换一次的 $16$ 种情况，再枚举切换两次的 $15\times15$ 种情况，以此类推。</p><p>由此看来，这样做效率十分低下。假设最少切换次数是 $12$，运算量也可以达到 $10^9$ 数量级，根本无法应对需要更多切换次数的情况。</p><p>所以我们引入如下方法，首先给这 $16$ 个火堆编号：</p><p>$$\begin{array}{|c|c|c|c|}\hline1&amp;2&amp;3&amp;4\\\hline5&amp;6&amp;7&amp;8\\\hline9&amp;10&amp;11&amp;12\\\hline13&amp;14&amp;15&amp;16\\\hline\end{array}$$</p><p>用 $b_i$ 表示第 $i$ 个火堆的状态，$b_i$ 取值 $1$ 为熄灭状态，取值 $0$ 为燃烧状态。样例中，$b$ 就可以如此表示为如下的 “状态向量”：</p><p>$$b=(1,1,1,0,1,0,0,1,1,0,0,1,0,1,1,1)^{\rm T}$$</p><p>接下来定义向量 $x$，用 $x_i$ 表示是否需要对第 $i$ 个火堆进行切换，是为 $1$，不是为 $0$&hairsp;。我们发现，火堆状态的切换可以用<strong>异或运算</strong>来表示；又由于火堆最终都将处于熄灭状态，我们可以对第一个火堆列出方程，并化简：</p><p>$$b_1\oplus x_1\oplus x_2\oplus x_3\oplus x_4\oplus x_5\oplus x_9\oplus x_{13} = 0$$</p><p>$$x_1\oplus x_2\oplus x_3\oplus x_4\oplus x_5\oplus x_9\oplus x_{13} = b_1$$</p><p>类似地，可以对第 $2,3,\ldots,16$ 个火堆列出方程，并组成方程组：</p><p>$$\begin{cases}x_1\oplus x_2\oplus x_3\oplus x_4\oplus x_5\oplus x_9\oplus x_{13}&amp;=&amp;b_1\\x_1\oplus x_2\oplus x_3\oplus x_4\oplus x_6\oplus x_{10}\oplus x_{14}&amp;=&amp;b_2\\\qquad\qquad\cdots\\x_4\oplus x_8\oplus x_{12}\oplus x_{13}\oplus x_{14}\oplus x_{15}\oplus x_{16}&amp;=&amp;b_{16}\end{cases}$$</p><p>于是，求解哪些火堆需要切换的问题则转化为了求解方程组的问题。</p><p>到了这一步，你的线性代数知识是否已被唤起？这里不再是线性方程组，而将线性方程中的加法换为异或，变为了 “异或方程组”，同样可以化为矩阵形式：</p><p>$$Ax=b\quad\Leftrightarrow\quad\left[\begin{array}{c}\textcolor{red}{1}\,\textcolor{red}{1}\,\textcolor{red}{1}\,\textcolor{red}{1}\,\textcolor{red}{1}\,0\,0\,0\,\textcolor{red}{1}\,0\,0\,0\,\textcolor{red}{1}\,0\,0\,0\\\textcolor{red}{1}\,\textcolor{red}{1}\,\textcolor{red}{1}\,\textcolor{red}{1}\,0\,\textcolor{red}{1}\,0\,0\,0\,\textcolor{red}{1}\,0\,0\,0\,\textcolor{red}{1}\,0\,0\\\cdots\;\text{another 13 lines}\;\cdots\\0\,0\,0\,\textcolor{red}{1}\,0\,0\,0\,\textcolor{red}{1}\,0\,0\,0\,\textcolor{red}{1}\,\textcolor{red}{1}\,\textcolor{red}{1}\,\textcolor{red}{1}\,\textcolor{red}{1}\end{array}\right]x=b$$</p><p>利用高斯消元法，对增广矩阵 $[A|b]$ 进行初等行变换（只包括行之间的异或运算），直到矩阵 $A$ 化为单位矩阵；而变换后的状态向量 $b$ 便成了我们需要求解的 $x$ 向量。</p><p>最后根据向量 $x$，按顺序输出即可。</p><p>如此，$4\times4$ 的 “传火” 问题，甚至是 $m\times n$ 的十字翻转棋问题，便能在 $O((mn)^2)$ 的时间复杂度下解决了。</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight c++"><figcaption><span>solution.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(bitset&lt;<span class="number">16</span>&gt;&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// generate matrix A</span></span><br><span class="line">    array&lt;bitset&lt;16&gt;, 16&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">4</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j != <span class="number">4</span>; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k != <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                A[i * <span class="number">4</span> + j].<span class="built_in">set</span>(i * <span class="number">4</span> + k);</span><br><span class="line">                A[i * <span class="number">4</span> + j].<span class="built_in">set</span>(k * <span class="number">4</span> + j);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">15</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// if A[i][i] is not a pivot</span></span><br><span class="line">        <span class="comment">// swap row i with the first row which has a pivot</span></span><br><span class="line">        <span class="keyword">if</span> (!A[i][i])</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j != <span class="number">16</span>; ++j)</span><br><span class="line">                <span class="keyword">if</span> (A[j][i]) &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(A[j], A[i]);</span><br><span class="line">                    <span class="type">bool</span> tmp = x[j];</span><br><span class="line">                    x[j] = x[i];</span><br><span class="line">                    x[i] = tmp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="comment">// eliminate</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j != <span class="number">16</span>; ++j)</span><br><span class="line">            <span class="keyword">if</span> (A[j][i]) &#123;</span><br><span class="line">                A[j] ^= A[i];</span><br><span class="line">                x[j] = x[j] ^ x[i];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// eliminate</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">15</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">            <span class="keyword">if</span> (A[j][i]) &#123;</span><br><span class="line">                A[j] ^= A[i];</span><br><span class="line">                x[j] = x[j] ^ x[i];</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitset&lt;16&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j != <span class="number">4</span>; ++j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">getchar</span>() == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">                x.<span class="built_in">set</span>(i * <span class="number">4</span> + j);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, x.<span class="built_in">count</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">16</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (x[i])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, (i / <span class="number">4</span>) + <span class="number">1</span>, (i % <span class="number">4</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm Contest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My Impression of Hexo</title>
      <link href="/posts/my-impression-of-hexo/"/>
      <url>/posts/my-impression-of-hexo/</url>
      
        <content type="html"><![CDATA[<p>Struggled for hours tweaking themes and preferences, I finally end up with this.</p><p>Hexo was amazing, that simple and elegant writing experience really captivates me.</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
